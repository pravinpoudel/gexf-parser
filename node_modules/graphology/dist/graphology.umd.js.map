{"version":3,"file":"graphology.umd.js","sources":["../src/utils.js","../../../node_modules/events/events.js","../../../node_modules/obliterator/iterator.js","../../../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../../../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function')\n  assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o)\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints))\n    return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes))\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected)\n    outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined')\n      adj[source] = container;\n  }\n  else {\n\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeGetter(Class, method, type) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributesGetter(Class, method, type) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributeChecker(Class, method, type) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeSetter(Class, method, type) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeUpdater(Class, method, type) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeRemover(Class, method, type) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesReplacer(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesMerger(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed'\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed'\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected'\n    );\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = require('./iterator.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object)\n    edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    ));\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback until\n * the return value of the callback is truthy.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimpleUntil(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachMultiUntil(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    iterator = object[k].values();\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected,\n        edgeData.generatedKey\n      );\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => callback(\n    edgeData.key,\n    edgeData.attributes,\n    edgeData.source.key,\n    edgeData.target.key,\n    edgeData.source.attributes,\n    edgeData.target.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  ));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback until it returns a truthy value to stop iteration.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimpleUntil(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return false;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  return callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMultiUntil(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return false;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask)\n      list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdgeUntil(graph, type, callback) {\n  if (graph.size === 0)\n    return false;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask)\n        continue;\n\n      break;\n    }\n\n    const value = [\n      data.key,\n      data.attributes,\n      data.source.key,\n      data.target.key,\n      data.source.attributes,\n      data.target.attributes\n    ];\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(edges, nodeData.in);\n    if (direction !== 'in')\n      fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNodeUntil(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMultiUntil : forEachSimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      shouldBreak = fn(nodeData.in, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n    if (direction !== 'in') {\n      shouldBreak = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = fn(nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out, !direction ? nodeData.key : null));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback until\n * it returns a truthy value to stop iteration.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPathUntil(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMultiUntil : forEachForKeySimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      shouldBreak = fn(sourceData.in, target, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        shouldBreak = fn(sourceData.out, target, callback, !direction ? sourceData.key : null);\n\n        if (shouldBreak)\n          return true;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      shouldBreak = fn(sourceData.undirected, target, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdgeUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback and breaking as soon as the callback return a truthy value.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdgeUntil(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNodeUntil(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPathUntil(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachUntilName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachForEachEdgeUntil(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback until it returns a truthy value to stop iteration.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectUntil(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachInObjectOnceUntil(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction forEachNeighborForNodeUntil(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectUntil(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObjectUntil(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.in, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n    if (direction !== 'in') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.out, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighborUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighborForNodeUntil(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachForEachNeighborUntil(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\nimport Iterator from 'obliterator/iterator';\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph     - Target Graph instance.\n * @param {callback} function  - Iteration callback.\n */\nexport function forEachAdjacencySimple(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return true;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor)\n          targetData = edgeData.source;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph    - Target Graph instance.\n * @param {callback} function - Iteration callback.\n */\nexport function forEachAdjacencyMulti(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, container, containerStep, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return true;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor)\n            targetData = edgeData.source;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function createAdjacencyIteratorSimple(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    const neighbor = neighbors[offset++];\n    const edgeData = adj[neighbor];\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n\nexport function createAdjacencyIteratorMulti(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      container = null,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (!container && offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    if (!container) {\n      const neighbor = neighbors[offset++];\n      container = adj[neighbor].values();\n      return next();\n    }\n\n    step = container.next();\n\n    if (step.done) {\n      container = null;\n      return next();\n    }\n\n    const edgeData = step.value;\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti,\n  createAdjacencyIteratorSimple,\n  createAdjacencyIteratorMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId,\n  validateHints\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`);\n    }\n    else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source.key !== source || edgeData.target.key !== target) ||\n        (undirected && (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`);\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdgeData &&\n    !graph.multi &&\n    sourceData\n  ) {\n    alreadyExistingEdgeData = undirected ?\n      sourceData.undirected[target] :\n      sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes)\n      return alreadyExistingEdgeData.key;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return alreadyExistingEdgeData.key;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater)\n    attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'selfLoopCount', () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'directedSelfLoopCount', () => this._directedSelfLoopCount);\n    readOnlyProperty(this, 'undirectedSelfLoopCount', () => this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        !edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const loops = selfLoops ? nodeData.undirectedSelfLoops : 0;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      if (selfLoops)\n        loops = nodeData.undirectedSelfLoops;\n\n      degree += nodeData.undirectedDegree + loops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      if (selfLoops)\n        loops = nodeData.directedSelfLoops;\n\n      degree += nodeData.inDegree + nodeData.outDegree + loops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const source = data.source.key,\n          target = data.target.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`);\n\n    return (\n      data.source.key === node ||\n      data.target.key === node\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isDirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**\n   * Method returning whether the given edge has a generated key.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  hasGeneratedKey(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasGeneratedKey: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.generatedKey;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`);\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return node;\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      }\n      else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.removeNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      edgeData.attributes = updater(edgeData.key, edgeData.attributes);\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(false, this, callback);\n    else\n      forEachAdjacencySimple(false, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      return forEachAdjacencyMulti(true, this, callback);\n\n    return forEachAdjacencySimple(true, this, callback);\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    if (this.multi)\n      return createAdjacencyIteratorMulti(this);\n\n    return createAdjacencyIteratorSimple(this);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function')\n      return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNodeUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData, shouldBreak;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n\n      shouldBreak = callback(nodeData.key, nodeData.attributes);\n\n      if (shouldBreak)\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid nodes. Expecting an array.');\n\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid edges. Expecting an array.');\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'directed')\n    throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalId","R","Reflect","ReflectApply","apply","receiver","args","Function","prototype","call","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","ProcessEmitWarning","warning","console","warn","NumberIsNaN","Number","isNaN","EventEmitter","init","eventsModule","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","set","arg","RangeError","getPrototypeOf","create","setMaxListeners","n","_getMaxListeners","that","getMaxListeners","emit","push","doError","events","error","er","Error","err","message","context","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","newListener","unshift","warned","w","String","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","list","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","arr","copy","index","pop","ret","Promise","resolve","reject","errorListener","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","Iterator","next","done","step","_next","Symbol","iterator","of","empty","is","take","Infinity","array","GraphError","data","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","EdgeData","generatedKey","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","adj","container","Set","add","clearEdgeFromStructureIndex","sourceIndex","size","targetIndex","clearStructureIndex","forEach","upgradeStructureIndexToMulti","node","neighbor","edges","attachAttributeGetter","Class","method","element","_edges","attachAttributesGetter","attachAttributeChecker","hasOwnProperty","attachAttributeSetter","attachAttributeUpdater","updater","attachAttributeRemover","attachAttributesReplacer","attachAttributesMerger","ATTRIBUTES_METHODS","attacher","attachAttributesMethods","Graph","require$$0","chain","iterators","current","iterate","EDGES_ITERATION","direction","collectSimple","object","collectMulti","forEachSimple","callback","avoid","forEachMulti","forEachSimpleUntil","shouldBreak","forEachMultiUntil","values","createIterator","inner","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","forEachForKeySimpleUntil","forEachForKeyMultiUntil","createIteratorForKey","v","createEdgeArray","from","undirectedSize","directedSize","mask","forEachEdge","shouldFilter","forEachEdgeUntil","createEdgeIterator","createEdgeArrayForNode","nodeData","fn","splice","lastIndexOf","forEachEdgeForNode","forEachEdgeForNodeUntil","createEdgeIteratorForNode","createEdgeArrayForPath","forEachEdgeForPath","forEachEdgeForPathUntil","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","attachForEachEdgeUntil","forEachUntilName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","forEachInObjectUntil","forEachInObjectOnceUntil","forEachNeighborForNode","forEachNeighborForNodeUntil","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","nodeHasNeighbor","attachNeighborArrayCreator","node1","node2","attachForEachNeighbor","attachForEachNeighborUntil","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacencySimple","breakable","forEachAdjacencyMulti","containerStep","createAdjacencyIteratorSimple","offset","createAdjacencyIteratorMulti","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","edgeKeyGenerator","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","oldAttributes","options","Map","prop","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","hasGeneratedKey","mergeNode","updateNode","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachUntil","adjacency","nodes","forEachNode","forEachNodeUntil","nodeEntries","exportNode","exportEdge","importNode","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","upgradeToMulti","toJSON","toString","inspect","multiIndex","label","desc","dummy","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAASA,cAAT,GAA0B;EACxB,MAAMC,MAAM,GAAGC,SAAS,CAAC,CAAD,CAAxB;;EAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCF,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;EAChD,QAAI,CAACD,SAAS,CAACC,CAAD,CAAd,EACE;;EAEF,SAAK,IAAMG,CAAX,IAAgBJ,SAAS,CAACC,CAAD,CAAzB;EACEF,MAAAA,MAAM,CAACK,CAAD,CAAN,GAAYJ,SAAS,CAACC,CAAD,CAAT,CAAaG,CAAb,CAAZ;EADF;EAED;;EAED,SAAOL,MAAP;EACD;;EAED,IAAIM,MAAM,GAAGP,cAAb;EAEA,IAAI,OAAOQ,MAAM,CAACD,MAAd,KAAyB,UAA7B,EACEA,MAAM,GAAGC,MAAM,CAACD,MAAhB;EAIF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASE,eAAT,CAAyBC,KAAzB,EAAgCC,MAAhC,EAAwCV,MAAxC,EAAgDW,IAAhD,EAAsD;EAC3D,MAAMC,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAnB;;EAEA,MAAIK,IAAI,GAAG,IAAX;EAEA,MAAI,CAACH,UAAL,EACE,OAAOG,IAAP;;EAEF,MAAIJ,IAAI,KAAK,OAAb,EAAsB;EACpBI,IAAAA,IAAI,GACDH,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAnB,IACCY,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAF5B;EAID,GALD,MAMK,IAAIW,IAAI,KAAK,UAAb,EAAyB;EAC5BI,IAAAA,IAAI,GAAGH,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAzB;EACD,GAFI,MAGA;EACHe,IAAAA,IAAI,GAAGH,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAAhC;EACD;;EAED,SAAOe,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASG,OAAT,CAAiBC,KAAjB,EAAwB;EAC7B,SACEA,KAAK,KAAK,IAAV,IACA,QAAOA,KAAP,MAAiB,QADjB,IAEA,OAAOA,KAAK,CAACC,wBAAb,KAA0C,UAF1C,IAGA,OAAOD,KAAK,CAACE,QAAb,KAA0B,UAJ5B;EAMD;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASC,aAAT,CAAuBH,KAAvB,EAA8B;EACnC,SACE,QAAOA,KAAP,MAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEAA,KAAK,CAACI,WAAN,KAAsBhB,MAHxB;EAKD;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASiB,OAAT,CAAiBC,CAAjB,EAAoB;EACzB,MAAIpB,CAAJ;;EAEA,OAAKA,CAAL,IAAUoB,CAAV;EACE,WAAO,KAAP;EADF;;EAGA,SAAO,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASC,eAAT,CAAyB1B,MAAzB,EAAiC2B,IAAjC,EAAuCR,KAAvC,EAA8C;EACnDZ,EAAAA,MAAM,CAACqB,cAAP,CAAsB5B,MAAtB,EAA8B2B,IAA9B,EAAoC;EAClCE,IAAAA,UAAU,EAAE,KADsB;EAElCC,IAAAA,YAAY,EAAE,KAFoB;EAGlCC,IAAAA,QAAQ,EAAE,IAHwB;EAIlCZ,IAAAA,KAAK,EAALA;EAJkC,GAApC;EAMD;EAGD;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASa,gBAAT,CAA0BhC,MAA1B,EAAkC2B,IAAlC,EAAwCR,KAAxC,EAA+C;EACpD,MAAMc,UAAU,GAAG;EACjBJ,IAAAA,UAAU,EAAE,IADK;EAEjBC,IAAAA,YAAY,EAAE;EAFG,GAAnB;;EAKA,MAAI,OAAOX,KAAP,KAAiB,UAArB,EAAiC;EAC/Bc,IAAAA,UAAU,CAACnB,GAAX,GAAiBK,KAAjB;EACD,GAFD,MAGK;EACHc,IAAAA,UAAU,CAACd,KAAX,GAAmBA,KAAnB;EACAc,IAAAA,UAAU,CAACF,QAAX,GAAsB,KAAtB;EACD;;EAEDxB,EAAAA,MAAM,CAACqB,cAAP,CAAsB5B,MAAtB,EAA8B2B,IAA9B,EAAoCM,UAApC;EACD;EAED;EACA;EACA;EACA;EACA;;EACO,SAASC,aAAT,CAAuBC,KAAvB,EAA8B;EACnC,MAAI,CAACb,aAAa,CAACa,KAAD,CAAlB,EACE,OAAO,KAAP;EAEF,MAAIA,KAAK,CAACC,UAAN,IAAoB,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAK,CAACC,UAApB,CAAzB,EACE,OAAO,KAAP;EAEF,SAAO,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;;EACO,SAASG,aAAT,GAAyB;EAC9B,MAAIrC,CAAC,GAAG,CAAR;EAEA,SAAO,YAAM;EACX,WAAOA,CAAC,EAAR;EACD,GAFD;EAGD;;;;EC9JD,IAAIsC,CAAC,GAAG,OAAOC,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,IAAhD;EACA,IAAIC,YAAY,GAAGF,CAAC,IAAI,OAAOA,CAAC,CAACG,KAAT,KAAmB,UAAxB,GACfH,CAAC,CAACG,KADa,GAEf,SAASD,YAAT,CAAsB1C,MAAtB,EAA8B4C,QAA9B,EAAwCC,IAAxC,EAA8C;EAC9C,SAAOC,QAAQ,CAACC,SAAT,CAAmBJ,KAAnB,CAAyBK,IAAzB,CAA8BhD,MAA9B,EAAsC4C,QAAtC,EAAgDC,IAAhD,CAAP;EACD,CAJH;EAMA,IAAII,cAAJ;;EACA,IAAIT,CAAC,IAAI,OAAOA,CAAC,CAACU,OAAT,KAAqB,UAA9B,EAA0C;EACxCD,EAAAA,cAAc,GAAGT,CAAC,CAACU,OAAnB;EACD,CAFD,MAEO,IAAI3C,MAAM,CAAC4C,qBAAX,EAAkC;EACvCF,EAAAA,cAAc,GAAG,SAASA,cAAT,CAAwBjD,MAAxB,EAAgC;EAC/C,WAAOO,MAAM,CAAC6C,mBAAP,CAA2BpD,MAA3B,EACJqD,MADI,CACG9C,MAAM,CAAC4C,qBAAP,CAA6BnD,MAA7B,CADH,CAAP;EAED,GAHD;EAID,CALM,MAKA;EACLiD,EAAAA,cAAc,GAAG,SAASA,cAAT,CAAwBjD,MAAxB,EAAgC;EAC/C,WAAOO,MAAM,CAAC6C,mBAAP,CAA2BpD,MAA3B,CAAP;EACD,GAFD;EAGD;;EAED,SAASsD,kBAAT,CAA4BC,OAA5B,EAAqC;EACnC,MAAIC,OAAO,IAAIA,OAAO,CAACC,IAAvB,EAA6BD,OAAO,CAACC,IAAR,CAAaF,OAAb;EAC9B;;EAED,IAAIG,WAAW,GAAGC,MAAM,CAACC,KAAP,IAAgB,SAASF,WAAT,CAAqBvC,KAArB,EAA4B;EAC5D,SAAOA,KAAK,KAAKA,KAAjB;EACD,CAFD;;EAIA,SAAS0C,YAAT,GAAwB;EACtBA,EAAAA,YAAY,CAACC,IAAb,CAAkBd,IAAlB,CAAuB,IAAvB;EACD;;AACDe,gBAAA,GAAiBF,YAAjB;wBACsBG;;EAGtBH,YAAY,CAACA,YAAb,GAA4BA,YAA5B;EAEAA,YAAY,CAACd,SAAb,CAAuBkB,OAAvB,GAAiCC,SAAjC;EACAL,YAAY,CAACd,SAAb,CAAuBoB,YAAvB,GAAsC,CAAtC;EACAN,YAAY,CAACd,SAAb,CAAuBqB,aAAvB,GAAuCF,SAAvC;EAGA;;EACA,IAAIG,mBAAmB,GAAG,EAA1B;;EAEA,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;EAC/B,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;EAClC,UAAM,IAAIC,SAAJ,CAAc,qEAAqE,OAAOD,QAA1F,CAAN;EACD;EACF;;EAEDhE,MAAM,CAACqB,cAAP,CAAsBiC,YAAtB,EAAoC,qBAApC,EAA2D;EACzDhC,EAAAA,UAAU,EAAE,IAD6C;EAEzDf,EAAAA,GAAG,EAAE,YAAW;EACd,WAAOuD,mBAAP;EACD,GAJwD;EAKzDI,EAAAA,GAAG,EAAE,UAASC,GAAT,EAAc;EACjB,QAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,GAAG,CAAjC,IAAsChB,WAAW,CAACgB,GAAD,CAArD,EAA4D;EAC1D,YAAM,IAAIC,UAAJ,CAAe,oGAAoGD,GAApG,GAA0G,GAAzH,CAAN;EACD;;EACDL,IAAAA,mBAAmB,GAAGK,GAAtB;EACD;EAVwD,CAA3D;;EAaAb,YAAY,CAACC,IAAb,GAAoB,YAAW;EAE7B,MAAI,KAAKG,OAAL,KAAiBC,SAAjB,IACA,KAAKD,OAAL,KAAiB1D,MAAM,CAACqE,cAAP,CAAsB,IAAtB,EAA4BX,OADjD,EAC0D;EACxD,SAAKA,OAAL,GAAe1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAAf;EACA,SAAKV,YAAL,GAAoB,CAApB;EACD;;EAED,OAAKC,aAAL,GAAqB,KAAKA,aAAL,IAAsBF,SAA3C;EACD,CATD;EAYA;;;EACAL,YAAY,CAACd,SAAb,CAAuB+B,eAAvB,GAAyC,SAASA,eAAT,CAAyBC,CAAzB,EAA4B;EACnE,MAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,GAAG,CAA7B,IAAkCrB,WAAW,CAACqB,CAAD,CAAjD,EAAsD;EACpD,UAAM,IAAIJ,UAAJ,CAAe,kFAAkFI,CAAlF,GAAsF,GAArG,CAAN;EACD;;EACD,OAAKX,aAAL,GAAqBW,CAArB;EACA,SAAO,IAAP;EACD,CAND;;EAQA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;EAC9B,MAAIA,IAAI,CAACb,aAAL,KAAuBF,SAA3B,EACE,OAAOL,YAAY,CAACQ,mBAApB;EACF,SAAOY,IAAI,CAACb,aAAZ;EACD;;EAEDP,YAAY,CAACd,SAAb,CAAuBmC,eAAvB,GAAyC,SAASA,eAAT,GAA2B;EAClE,SAAOF,gBAAgB,CAAC,IAAD,CAAvB;EACD,CAFD;;EAIAnB,YAAY,CAACd,SAAb,CAAuBoC,IAAvB,GAA8B,SAASA,IAAT,CAAcxE,IAAd,EAAoB;EAChD,MAAIkC,IAAI,GAAG,EAAX;;EACA,OAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACG,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C2C,IAAI,CAACuC,IAAL,CAAUnF,SAAS,CAACC,CAAD,CAAnB;;EAC3C,MAAImF,OAAO,GAAI1E,IAAI,KAAK,OAAxB;EAEA,MAAI2E,MAAM,GAAG,KAAKrB,OAAlB;EACA,MAAIqB,MAAM,KAAKpB,SAAf,EACEmB,OAAO,GAAIA,OAAO,IAAIC,MAAM,CAACC,KAAP,KAAiBrB,SAAvC,CADF,KAEK,IAAI,CAACmB,OAAL,EACH,OAAO,KAAP,CAT8C;;EAYhD,MAAIA,OAAJ,EAAa;EACX,QAAIG,EAAJ;EACA,QAAI3C,IAAI,CAACzC,MAAL,GAAc,CAAlB,EACEoF,EAAE,GAAG3C,IAAI,CAAC,CAAD,CAAT;;EACF,QAAI2C,EAAE,YAAYC,KAAlB,EAAyB;;;EAGvB,YAAMD,EAAN,CAHuB;EAIxB,KARU;;;EAUX,QAAIE,GAAG,GAAG,IAAID,KAAJ,CAAU,sBAAsBD,EAAE,GAAG,OAAOA,EAAE,CAACG,OAAV,GAAoB,GAAvB,GAA6B,EAArD,CAAV,CAAV;EACAD,IAAAA,GAAG,CAACE,OAAJ,GAAcJ,EAAd;EACA,UAAME,GAAN,CAZW;EAaZ;;EAED,MAAIG,OAAO,GAAGP,MAAM,CAAC3E,IAAD,CAApB;EAEA,MAAIkF,OAAO,KAAK3B,SAAhB,EACE,OAAO,KAAP;;EAEF,MAAI,OAAO2B,OAAP,KAAmB,UAAvB,EAAmC;EACjCnD,IAAAA,YAAY,CAACmD,OAAD,EAAU,IAAV,EAAgBhD,IAAhB,CAAZ;EACD,GAFD,MAEO;EACL,QAAIiD,GAAG,GAAGD,OAAO,CAACzF,MAAlB;EACA,QAAI2F,SAAS,GAAGC,UAAU,CAACH,OAAD,EAAUC,GAAV,CAA1B;;EACA,SAAK,IAAI5F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4F,GAApB,EAAyB,EAAE5F,CAA3B,EACEwC,YAAY,CAACqD,SAAS,CAAC7F,CAAD,CAAV,EAAe,IAAf,EAAqB2C,IAArB,CAAZ;EACH;;EAED,SAAO,IAAP;EACD,CA1CD;;EA4CA,SAASoD,YAAT,CAAsBjG,MAAtB,EAA8BW,IAA9B,EAAoC4D,QAApC,EAA8C2B,OAA9C,EAAuD;EACrD,MAAIC,CAAJ;EACA,MAAIb,MAAJ;EACA,MAAIc,QAAJ;EAEA9B,EAAAA,aAAa,CAACC,QAAD,CAAb;EAEAe,EAAAA,MAAM,GAAGtF,MAAM,CAACiE,OAAhB;;EACA,MAAIqB,MAAM,KAAKpB,SAAf,EAA0B;EACxBoB,IAAAA,MAAM,GAAGtF,MAAM,CAACiE,OAAP,GAAiB1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAA1B;EACA7E,IAAAA,MAAM,CAACmE,YAAP,GAAsB,CAAtB;EACD,GAHD,MAGO;;;EAGL,QAAImB,MAAM,CAACe,WAAP,KAAuBnC,SAA3B,EAAsC;EACpClE,MAAAA,MAAM,CAACmF,IAAP,CAAY,aAAZ,EAA2BxE,IAA3B,EACY4D,QAAQ,CAACA,QAAT,GAAoBA,QAAQ,CAACA,QAA7B,GAAwCA,QADpD,EADoC;;;EAMpCe,MAAAA,MAAM,GAAGtF,MAAM,CAACiE,OAAhB;EACD;;EACDmC,IAAAA,QAAQ,GAAGd,MAAM,CAAC3E,IAAD,CAAjB;EACD;;EAED,MAAIyF,QAAQ,KAAKlC,SAAjB,EAA4B;;EAE1BkC,IAAAA,QAAQ,GAAGd,MAAM,CAAC3E,IAAD,CAAN,GAAe4D,QAA1B;EACA,MAAEvE,MAAM,CAACmE,YAAT;EACD,GAJD,MAIO;EACL,QAAI,OAAOiC,QAAP,KAAoB,UAAxB,EAAoC;;EAElCA,MAAAA,QAAQ,GAAGd,MAAM,CAAC3E,IAAD,CAAN,GACTuF,OAAO,GAAG,CAAC3B,QAAD,EAAW6B,QAAX,CAAH,GAA0B,CAACA,QAAD,EAAW7B,QAAX,CADnC,CAFkC;EAKnC,KALD,MAKO,IAAI2B,OAAJ,EAAa;EAClBE,MAAAA,QAAQ,CAACE,OAAT,CAAiB/B,QAAjB;EACD,KAFM,MAEA;EACL6B,MAAAA,QAAQ,CAAChB,IAAT,CAAcb,QAAd;EACD,KAVI;;;EAaL4B,IAAAA,CAAC,GAAGnB,gBAAgB,CAAChF,MAAD,CAApB;;EACA,QAAImG,CAAC,GAAG,CAAJ,IAASC,QAAQ,CAAChG,MAAT,GAAkB+F,CAA3B,IAAgC,CAACC,QAAQ,CAACG,MAA9C,EAAsD;EACpDH,MAAAA,QAAQ,CAACG,MAAT,GAAkB,IAAlB,CADoD;;;EAIpD,UAAIC,CAAC,GAAG,IAAIf,KAAJ,CAAU,iDACEW,QAAQ,CAAChG,MADX,GACoB,GADpB,GAC0BqG,MAAM,CAAC9F,IAAD,CADhC,GACyC,aADzC,GAEE,0CAFF,GAGE,gBAHZ,CAAR;EAIA6F,MAAAA,CAAC,CAAC7E,IAAF,GAAS,6BAAT;EACA6E,MAAAA,CAAC,CAACE,OAAF,GAAY1G,MAAZ;EACAwG,MAAAA,CAAC,CAAC7F,IAAF,GAASA,IAAT;EACA6F,MAAAA,CAAC,CAACG,KAAF,GAAUP,QAAQ,CAAChG,MAAnB;EACAkD,MAAAA,kBAAkB,CAACkD,CAAD,CAAlB;EACD;EACF;;EAED,SAAOxG,MAAP;EACD;;EAED6D,YAAY,CAACd,SAAb,CAAuB6D,WAAvB,GAAqC,SAASA,WAAT,CAAqBjG,IAArB,EAA2B4D,QAA3B,EAAqC;EACxE,SAAO0B,YAAY,CAAC,IAAD,EAAOtF,IAAP,EAAa4D,QAAb,EAAuB,KAAvB,CAAnB;EACD,CAFD;;EAIAV,YAAY,CAACd,SAAb,CAAuB8D,EAAvB,GAA4BhD,YAAY,CAACd,SAAb,CAAuB6D,WAAnD;;EAEA/C,YAAY,CAACd,SAAb,CAAuB+D,eAAvB,GACI,SAASA,eAAT,CAAyBnG,IAAzB,EAA+B4D,QAA/B,EAAyC;EACvC,SAAO0B,YAAY,CAAC,IAAD,EAAOtF,IAAP,EAAa4D,QAAb,EAAuB,IAAvB,CAAnB;EACD,CAHL;;EAKA,SAASwC,WAAT,GAAuB;EACrB,MAAI,CAAC,KAAKC,KAAV,EAAiB;EACf,SAAKhH,MAAL,CAAYiH,cAAZ,CAA2B,KAAKtG,IAAhC,EAAsC,KAAKuG,MAA3C;EACA,SAAKF,KAAL,GAAa,IAAb;EACA,QAAI/G,SAAS,CAACG,MAAV,KAAqB,CAAzB,EACE,OAAO,KAAKmE,QAAL,CAAcvB,IAAd,CAAmB,KAAKhD,MAAxB,CAAP;EACF,WAAO,KAAKuE,QAAL,CAAc5B,KAAd,CAAoB,KAAK3C,MAAzB,EAAiCC,SAAjC,CAAP;EACD;EACF;;EAED,SAASkH,SAAT,CAAmBnH,MAAnB,EAA2BW,IAA3B,EAAiC4D,QAAjC,EAA2C;EACzC,MAAI6C,KAAK,GAAG;EAAEJ,IAAAA,KAAK,EAAE,KAAT;EAAgBE,IAAAA,MAAM,EAAEhD,SAAxB;EAAmClE,IAAAA,MAAM,EAAEA,MAA3C;EAAmDW,IAAAA,IAAI,EAAEA,IAAzD;EAA+D4D,IAAAA,QAAQ,EAAEA;EAAzE,GAAZ;EACA,MAAI8C,OAAO,GAAGN,WAAW,CAACO,IAAZ,CAAiBF,KAAjB,CAAd;EACAC,EAAAA,OAAO,CAAC9C,QAAR,GAAmBA,QAAnB;EACA6C,EAAAA,KAAK,CAACF,MAAN,GAAeG,OAAf;EACA,SAAOA,OAAP;EACD;;EAEDxD,YAAY,CAACd,SAAb,CAAuBiB,IAAvB,GAA8B,SAASA,IAAT,CAAcrD,IAAd,EAAoB4D,QAApB,EAA8B;EAC1DD,EAAAA,aAAa,CAACC,QAAD,CAAb;EACA,OAAKsC,EAAL,CAAQlG,IAAR,EAAcwG,SAAS,CAAC,IAAD,EAAOxG,IAAP,EAAa4D,QAAb,CAAvB;EACA,SAAO,IAAP;EACD,CAJD;;EAMAV,YAAY,CAACd,SAAb,CAAuBwE,mBAAvB,GACI,SAASA,mBAAT,CAA6B5G,IAA7B,EAAmC4D,QAAnC,EAA6C;EAC3CD,EAAAA,aAAa,CAACC,QAAD,CAAb;EACA,OAAKuC,eAAL,CAAqBnG,IAArB,EAA2BwG,SAAS,CAAC,IAAD,EAAOxG,IAAP,EAAa4D,QAAb,CAApC;EACA,SAAO,IAAP;EACD,CALL;;;EAQAV,YAAY,CAACd,SAAb,CAAuBkE,cAAvB,GACI,SAASA,cAAT,CAAwBtG,IAAxB,EAA8B4D,QAA9B,EAAwC;EACtC,MAAIiD,IAAJ,EAAUlC,MAAV,EAAkBmC,QAAlB,EAA4BvH,CAA5B,EAA+BwH,gBAA/B;EAEApD,EAAAA,aAAa,CAACC,QAAD,CAAb;EAEAe,EAAAA,MAAM,GAAG,KAAKrB,OAAd;EACA,MAAIqB,MAAM,KAAKpB,SAAf,EACE,OAAO,IAAP;EAEFsD,EAAAA,IAAI,GAAGlC,MAAM,CAAC3E,IAAD,CAAb;EACA,MAAI6G,IAAI,KAAKtD,SAAb,EACE,OAAO,IAAP;;EAEF,MAAIsD,IAAI,KAAKjD,QAAT,IAAqBiD,IAAI,CAACjD,QAAL,KAAkBA,QAA3C,EAAqD;EACnD,QAAI,EAAE,KAAKJ,YAAP,KAAwB,CAA5B,EACE,KAAKF,OAAL,GAAe1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAAf,CADF,KAEK;EACH,aAAOS,MAAM,CAAC3E,IAAD,CAAb;EACA,UAAI2E,MAAM,CAAC2B,cAAX,EACE,KAAK9B,IAAL,CAAU,gBAAV,EAA4BxE,IAA5B,EAAkC6G,IAAI,CAACjD,QAAL,IAAiBA,QAAnD;EACH;EACF,GARD,MAQO,IAAI,OAAOiD,IAAP,KAAgB,UAApB,EAAgC;EACrCC,IAAAA,QAAQ,GAAG,CAAC,CAAZ;;EAEA,SAAKvH,CAAC,GAAGsH,IAAI,CAACpH,MAAL,GAAc,CAAvB,EAA0BF,CAAC,IAAI,CAA/B,EAAkCA,CAAC,EAAnC,EAAuC;EACrC,UAAIsH,IAAI,CAACtH,CAAD,CAAJ,KAAYqE,QAAZ,IAAwBiD,IAAI,CAACtH,CAAD,CAAJ,CAAQqE,QAAR,KAAqBA,QAAjD,EAA2D;EACzDmD,QAAAA,gBAAgB,GAAGF,IAAI,CAACtH,CAAD,CAAJ,CAAQqE,QAA3B;EACAkD,QAAAA,QAAQ,GAAGvH,CAAX;EACA;EACD;EACF;;EAED,QAAIuH,QAAQ,GAAG,CAAf,EACE,OAAO,IAAP;EAEF,QAAIA,QAAQ,KAAK,CAAjB,EACED,IAAI,CAACG,KAAL,GADF,KAEK;EACHC,MAAAA,SAAS,CAACJ,IAAD,EAAOC,QAAP,CAAT;EACD;EAED,QAAID,IAAI,CAACpH,MAAL,KAAgB,CAApB,EACEkF,MAAM,CAAC3E,IAAD,CAAN,GAAe6G,IAAI,CAAC,CAAD,CAAnB;EAEF,QAAIlC,MAAM,CAAC2B,cAAP,KAA0B/C,SAA9B,EACE,KAAKiB,IAAL,CAAU,gBAAV,EAA4BxE,IAA5B,EAAkC+G,gBAAgB,IAAInD,QAAtD;EACH;;EAED,SAAO,IAAP;EACD,CAlDL;;EAoDAV,YAAY,CAACd,SAAb,CAAuB8E,GAAvB,GAA6BhE,YAAY,CAACd,SAAb,CAAuBkE,cAApD;;EAEApD,YAAY,CAACd,SAAb,CAAuB+E,kBAAvB,GACI,SAASA,kBAAT,CAA4BnH,IAA5B,EAAkC;EAChC,MAAIoF,SAAJ,EAAeT,MAAf,EAAuBpF,CAAvB;EAEAoF,EAAAA,MAAM,GAAG,KAAKrB,OAAd;EACA,MAAIqB,MAAM,KAAKpB,SAAf,EACE,OAAO,IAAP,CAL8B;;EAQhC,MAAIoB,MAAM,CAAC2B,cAAP,KAA0B/C,SAA9B,EAAyC;EACvC,QAAIjE,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,WAAK6D,OAAL,GAAe1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAAf;EACA,WAAKV,YAAL,GAAoB,CAApB;EACD,KAHD,MAGO,IAAImB,MAAM,CAAC3E,IAAD,CAAN,KAAiBuD,SAArB,EAAgC;EACrC,UAAI,EAAE,KAAKC,YAAP,KAAwB,CAA5B,EACE,KAAKF,OAAL,GAAe1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAAf,CADF,KAGE,OAAOS,MAAM,CAAC3E,IAAD,CAAb;EACH;;EACD,WAAO,IAAP;EACD,GAnB+B;;;EAsBhC,MAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,QAAI2H,IAAI,GAAGxH,MAAM,CAACwH,IAAP,CAAYzC,MAAZ,CAAX;EACA,QAAI0C,GAAJ;;EACA,SAAK9H,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG6H,IAAI,CAAC3H,MAArB,EAA6B,EAAEF,CAA/B,EAAkC;EAChC8H,MAAAA,GAAG,GAAGD,IAAI,CAAC7H,CAAD,CAAV;EACA,UAAI8H,GAAG,KAAK,gBAAZ,EAA8B;EAC9B,WAAKF,kBAAL,CAAwBE,GAAxB;EACD;;EACD,SAAKF,kBAAL,CAAwB,gBAAxB;EACA,SAAK7D,OAAL,GAAe1D,MAAM,CAACsE,MAAP,CAAc,IAAd,CAAf;EACA,SAAKV,YAAL,GAAoB,CAApB;EACA,WAAO,IAAP;EACD;;EAED4B,EAAAA,SAAS,GAAGT,MAAM,CAAC3E,IAAD,CAAlB;;EAEA,MAAI,OAAOoF,SAAP,KAAqB,UAAzB,EAAqC;EACnC,SAAKkB,cAAL,CAAoBtG,IAApB,EAA0BoF,SAA1B;EACD,GAFD,MAEO,IAAIA,SAAS,KAAK7B,SAAlB,EAA6B;;EAElC,SAAKhE,CAAC,GAAG6F,SAAS,CAAC3F,MAAV,GAAmB,CAA5B,EAA+BF,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;EAC1C,WAAK+G,cAAL,CAAoBtG,IAApB,EAA0BoF,SAAS,CAAC7F,CAAD,CAAnC;EACD;EACF;;EAED,SAAO,IAAP;EACD,CAjDL;;EAmDA,SAAS+H,UAAT,CAAoBjI,MAApB,EAA4BW,IAA5B,EAAkCuH,MAAlC,EAA0C;EACxC,MAAI5C,MAAM,GAAGtF,MAAM,CAACiE,OAApB;EAEA,MAAIqB,MAAM,KAAKpB,SAAf,EACE,OAAO,EAAP;EAEF,MAAIiE,UAAU,GAAG7C,MAAM,CAAC3E,IAAD,CAAvB;EACA,MAAIwH,UAAU,KAAKjE,SAAnB,EACE,OAAO,EAAP;EAEF,MAAI,OAAOiE,UAAP,KAAsB,UAA1B,EACE,OAAOD,MAAM,GAAG,CAACC,UAAU,CAAC5D,QAAX,IAAuB4D,UAAxB,CAAH,GAAyC,CAACA,UAAD,CAAtD;EAEF,SAAOD,MAAM,GACXE,eAAe,CAACD,UAAD,CADJ,GACmBnC,UAAU,CAACmC,UAAD,EAAaA,UAAU,CAAC/H,MAAxB,CAD1C;EAED;;EAEDyD,YAAY,CAACd,SAAb,CAAuBgD,SAAvB,GAAmC,SAASA,SAAT,CAAmBpF,IAAnB,EAAyB;EAC1D,SAAOsH,UAAU,CAAC,IAAD,EAAOtH,IAAP,EAAa,IAAb,CAAjB;EACD,CAFD;;EAIAkD,YAAY,CAACd,SAAb,CAAuBsF,YAAvB,GAAsC,SAASA,YAAT,CAAsB1H,IAAtB,EAA4B;EAChE,SAAOsH,UAAU,CAAC,IAAD,EAAOtH,IAAP,EAAa,KAAb,CAAjB;EACD,CAFD;;EAIAkD,YAAY,CAACyE,aAAb,GAA6B,UAAS5B,OAAT,EAAkB/F,IAAlB,EAAwB;EACnD,MAAI,OAAO+F,OAAO,CAAC4B,aAAf,KAAiC,UAArC,EAAiD;EAC/C,WAAO5B,OAAO,CAAC4B,aAAR,CAAsB3H,IAAtB,CAAP;EACD,GAFD,MAEO;EACL,WAAO2H,aAAa,CAACtF,IAAd,CAAmB0D,OAAnB,EAA4B/F,IAA5B,CAAP;EACD;EACF,CAND;;EAQAkD,YAAY,CAACd,SAAb,CAAuBuF,aAAvB,GAAuCA,aAAvC;;EACA,SAASA,aAAT,CAAuB3H,IAAvB,EAA6B;EAC3B,MAAI2E,MAAM,GAAG,KAAKrB,OAAlB;;EAEA,MAAIqB,MAAM,KAAKpB,SAAf,EAA0B;EACxB,QAAIiE,UAAU,GAAG7C,MAAM,CAAC3E,IAAD,CAAvB;;EAEA,QAAI,OAAOwH,UAAP,KAAsB,UAA1B,EAAsC;EACpC,aAAO,CAAP;EACD,KAFD,MAEO,IAAIA,UAAU,KAAKjE,SAAnB,EAA8B;EACnC,aAAOiE,UAAU,CAAC/H,MAAlB;EACD;EACF;;EAED,SAAO,CAAP;EACD;;EAEDyD,YAAY,CAACd,SAAb,CAAuBwF,UAAvB,GAAoC,SAASA,UAAT,GAAsB;EACxD,SAAO,KAAKpE,YAAL,GAAoB,CAApB,GAAwBlB,cAAc,CAAC,KAAKgB,OAAN,CAAtC,GAAuD,EAA9D;EACD,CAFD;;EAIA,SAAS+B,UAAT,CAAoBwC,GAApB,EAAyBzD,CAAzB,EAA4B;EAC1B,MAAI0D,IAAI,GAAG,IAAIpG,KAAJ,CAAU0C,CAAV,CAAX;;EACA,OAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6E,CAApB,EAAuB,EAAE7E,CAAzB,EACEuI,IAAI,CAACvI,CAAD,CAAJ,GAAUsI,GAAG,CAACtI,CAAD,CAAb;;EACF,SAAOuI,IAAP;EACD;;EAED,SAASb,SAAT,CAAmBJ,IAAnB,EAAyBkB,KAAzB,EAAgC;EAC9B,SAAOA,KAAK,GAAG,CAAR,GAAYlB,IAAI,CAACpH,MAAxB,EAAgCsI,KAAK,EAArC,EACElB,IAAI,CAACkB,KAAD,CAAJ,GAAclB,IAAI,CAACkB,KAAK,GAAG,CAAT,CAAlB;;EACFlB,EAAAA,IAAI,CAACmB,GAAL;EACD;;EAED,SAASP,eAAT,CAAyBI,GAAzB,EAA8B;EAC5B,MAAII,GAAG,GAAG,IAAIvG,KAAJ,CAAUmG,GAAG,CAACpI,MAAd,CAAV;;EACA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0I,GAAG,CAACxI,MAAxB,EAAgC,EAAEF,CAAlC,EAAqC;EACnC0I,IAAAA,GAAG,CAAC1I,CAAD,CAAH,GAASsI,GAAG,CAACtI,CAAD,CAAH,CAAOqE,QAAP,IAAmBiE,GAAG,CAACtI,CAAD,CAA/B;EACD;;EACD,SAAO0I,GAAP;EACD;;EAED,SAAS5E,IAAT,CAAc0C,OAAd,EAAuB/E,IAAvB,EAA6B;EAC3B,SAAO,IAAIkH,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;EAC5C,aAASC,aAAT,CAAuBtD,GAAvB,EAA4B;EAC1BgB,MAAAA,OAAO,CAACO,cAAR,CAAuBtF,IAAvB,EAA6BsH,QAA7B;EACAF,MAAAA,MAAM,CAACrD,GAAD,CAAN;EACD;;EAED,aAASuD,QAAT,GAAoB;EAClB,UAAI,OAAOvC,OAAO,CAACO,cAAf,KAAkC,UAAtC,EAAkD;EAChDP,QAAAA,OAAO,CAACO,cAAR,CAAuB,OAAvB,EAAgC+B,aAAhC;EACD;;EACDF,MAAAA,OAAO,CAAC,GAAGI,KAAH,CAASlG,IAAT,CAAc/C,SAAd,CAAD,CAAP;EACD;EAEDkJ,IAAAA,8BAA8B,CAACzC,OAAD,EAAU/E,IAAV,EAAgBsH,QAAhB,EAA0B;EAAEjF,MAAAA,IAAI,EAAE;EAAR,KAA1B,CAA9B;;EACA,QAAIrC,IAAI,KAAK,OAAb,EAAsB;EACpByH,MAAAA,6BAA6B,CAAC1C,OAAD,EAAUsC,aAAV,EAAyB;EAAEhF,QAAAA,IAAI,EAAE;EAAR,OAAzB,CAA7B;EACD;EACF,GAjBM,CAAP;EAkBD;;EAED,SAASoF,6BAAT,CAAuC1C,OAAvC,EAAgDb,OAAhD,EAAyDwD,KAAzD,EAAgE;EAC9D,MAAI,OAAO3C,OAAO,CAACG,EAAf,KAAsB,UAA1B,EAAsC;EACpCsC,IAAAA,8BAA8B,CAACzC,OAAD,EAAU,OAAV,EAAmBb,OAAnB,EAA4BwD,KAA5B,CAA9B;EACD;EACF;;EAED,SAASF,8BAAT,CAAwCzC,OAAxC,EAAiD/E,IAAjD,EAAuD4C,QAAvD,EAAiE8E,KAAjE,EAAwE;EACtE,MAAI,OAAO3C,OAAO,CAACG,EAAf,KAAsB,UAA1B,EAAsC;EACpC,QAAIwC,KAAK,CAACrF,IAAV,EAAgB;EACd0C,MAAAA,OAAO,CAAC1C,IAAR,CAAarC,IAAb,EAAmB4C,QAAnB;EACD,KAFD,MAEO;EACLmC,MAAAA,OAAO,CAACG,EAAR,CAAWlF,IAAX,EAAiB4C,QAAjB;EACD;EACF,GAND,MAMO,IAAI,OAAOmC,OAAO,CAAC4C,gBAAf,KAAoC,UAAxC,EAAoD;;;EAGzD5C,IAAAA,OAAO,CAAC4C,gBAAR,CAAyB3H,IAAzB,EAA+B,SAAS4H,YAAT,CAAsB7E,GAAtB,EAA2B;;;EAGxD,UAAI2E,KAAK,CAACrF,IAAV,EAAgB;EACd0C,QAAAA,OAAO,CAAC8C,mBAAR,CAA4B7H,IAA5B,EAAkC4H,YAAlC;EACD;;EACDhF,MAAAA,QAAQ,CAACG,GAAD,CAAR;EACD,KAPD;EAQD,GAXM,MAWA;EACL,UAAM,IAAIF,SAAJ,CAAc,wEAAwE,OAAOkC,OAA7F,CAAN;EACD;;;;;;;;;ECxeH;EACA;EACA;EACA;EACA;EACA;;EACA,SAAS+C,UAAT,CAAkBC,IAAlB,EAAwB;;EAGtBnJ,EAAAA,MAAM,CAACqB,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;EACnCG,IAAAA,QAAQ,EAAE,KADyB;EAEnCF,IAAAA,UAAU,EAAE,KAFuB;EAGnCV,IAAAA,KAAK,EAAEuI;EAH4B,GAArC,EAHsB;;EAUtB,OAAKC,IAAL,GAAY,KAAZ;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;;AACAF,YAAQ,CAAC1G,SAAT,CAAmB2G,IAAnB,GAA0B,YAAW;EACnC,MAAI,KAAKC,IAAT,EACE,OAAO;EAACA,IAAAA,IAAI,EAAE;EAAP,GAAP;;EAEF,MAAIC,IAAI,GAAG,KAAKC,KAAL,EAAX;;EAEA,MAAID,IAAI,CAACD,IAAT,EACE,KAAKA,IAAL,GAAY,IAAZ;EAEF,SAAOC,IAAP;EACD,CAVD;EAYA;EACA;EACA;;;EACA,IAAI,OAAOE,MAAP,KAAkB,WAAtB,EACEL,UAAQ,CAAC1G,SAAT,CAAmB+G,MAAM,CAACC,QAA1B,IAAsC,YAAW;EAC/C,SAAO,IAAP;EACD,CAFD;EAIF;EACA;EACA;EACA;EACA;EACA;;AACAN,YAAQ,CAACO,EAAT,GAAc,YAAW;EACvB,MAAInH,IAAI,GAAG5C,SAAX;EAAA,MACIE,CAAC,GAAG0C,IAAI,CAACzC,MADb;EAAA,MAEIF,CAAC,GAAG,CAFR;EAIA,SAAO,IAAIuJ,UAAJ,CAAa,YAAW;EAC7B,QAAIvJ,CAAC,IAAIC,CAAT,EACE,OAAO;EAACwJ,MAAAA,IAAI,EAAE;EAAP,KAAP;EAEF,WAAO;EAACA,MAAAA,IAAI,EAAE,KAAP;EAAcxI,MAAAA,KAAK,EAAE0B,IAAI,CAAC3C,CAAC,EAAF;EAAzB,KAAP;EACD,GALM,CAAP;EAMD,CAXD;EAaA;EACA;EACA;EACA;EACA;;;AACAuJ,YAAQ,CAACQ,KAAT,GAAiB,YAAW;EAC1B,MAAIF,QAAQ,GAAG,IAAIN,UAAJ,CAAa,IAAb,CAAf;EACAM,EAAAA,QAAQ,CAACJ,IAAT,GAAgB,IAAhB;EAEA,SAAOI,QAAP;EACD,CALD;EAOA;EACA;EACA;EACA;EACA;EACA;;;AACAN,YAAQ,CAACS,EAAT,GAAc,UAAS/I,KAAT,EAAgB;EAC5B,MAAIA,KAAK,YAAYsI,UAArB,EACE,OAAO,IAAP;EAEF,SACE,OAAOtI,KAAP,KAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEA,OAAOA,KAAK,CAACuI,IAAb,KAAsB,UAHxB;EAKD,CATD;EAWA;EACA;EACA;;;MACAK,QAAc,GAAGN;;;ECtGjB;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;MACAU,IAAc,GAAG,SAASA,IAAT,CAAcJ,QAAd,EAAwBhF,CAAxB,EAA2B;EAC1C,MAAI5E,CAAC,GAAGF,SAAS,CAACG,MAAV,GAAmB,CAAnB,GAAuB2E,CAAvB,GAA2BqF,QAAnC;EAAA,MACIC,KAAK,GAAGlK,CAAC,KAAKiK,QAAN,GAAiB,IAAI/H,KAAJ,CAAUlC,CAAV,CAAjB,GAAgC,EAD5C;EAAA,MAEIyJ,IAFJ;EAAA,MAGI1J,CAAC,GAAG,CAHR;;EAKA,SAAO,IAAP,EAAa;EAEX,QAAIA,CAAC,KAAKC,CAAV,EACE,OAAOkK,KAAP;EAEFT,IAAAA,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP;;EAEA,QAAIE,IAAI,CAACD,IAAT,EAAe;EAEb,UAAIzJ,CAAC,KAAK6E,CAAV,EACE,OAAOsF,KAAK,CAACnB,KAAN,CAAY,CAAZ,EAAehJ,CAAf,CAAP;EAEF,aAAOmK,KAAP;EACD;;EAEDA,IAAAA,KAAK,CAACnK,CAAC,EAAF,CAAL,GAAa0J,IAAI,CAACzI,KAAlB;EACD;EACF;;ECvCD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;MACamJ,UAAb;EAAA;;EACE,sBAAY3E,OAAZ,EAAqB4E,IAArB,EAA2B;EAAA;;EACzB;EACA,UAAK5I,IAAL,GAAY,YAAZ;EACA,UAAKgE,OAAL,GAAeA,OAAO,IAAI,EAA1B;EACA,UAAK4E,IAAL,GAAYA,IAAI,IAAI,EAApB;EAJyB;EAK1B;;EANH;EAAA,iCAAgC9E,KAAhC;MASa+E,0BAAb;EAAA;;EACE,sCAAY7E,OAAZ,EAAqB4E,IAArB,EAA2B;EAAA;;EACzB,oCAAM5E,OAAN,EAAe4E,IAAf;EACA,WAAK5I,IAAL,GAAY,4BAAZ,CAFyB;;EAKzB,QAAI,OAAO8D,KAAK,CAACgF,iBAAb,KAAmC,UAAvC,EACEhF,KAAK,CAACgF,iBAAN,iCAA8BD,0BAA0B,CAACzH,SAA3B,CAAqCxB,WAAnE;EANuB;EAO1B;;EARH;EAAA,EAAgD+I,UAAhD;MAWaI,kBAAb;EAAA;;EACE,8BAAY/E,OAAZ,EAAqB4E,IAArB,EAA2B;EAAA;;EACzB,qCAAM5E,OAAN,EAAe4E,IAAf;EACA,WAAK5I,IAAL,GAAY,oBAAZ,CAFyB;;EAKzB,QAAI,OAAO8D,KAAK,CAACgF,iBAAb,KAAmC,UAAvC,EACEhF,KAAK,CAACgF,iBAAN,iCAA8BC,kBAAkB,CAAC3H,SAAnB,CAA6BxB,WAA3D;EANuB;EAO1B;;EARH;EAAA,EAAwC+I,UAAxC;MAWaK,eAAb;EAAA;;EACE,2BAAYhF,OAAZ,EAAqB4E,IAArB,EAA2B;EAAA;;EACzB,qCAAM5E,OAAN,EAAe4E,IAAf;EACA,WAAK5I,IAAL,GAAY,iBAAZ,CAFyB;;EAKzB,QAAI,OAAO8D,KAAK,CAACgF,iBAAb,KAAmC,UAAvC,EACEhF,KAAK,CAACgF,iBAAN,iCAA8BE,eAAe,CAAC5H,SAAhB,CAA0BxB,WAAxD;EANuB;EAO1B;;EARH;EAAA,EAAqC+I,UAArC;;ECvCA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACO,SAASM,aAAT,CAAuB5C,GAAvB,EAA4B5F,UAA5B,EAAwC;EAE7C;EACA,OAAK4F,GAAL,GAAWA,GAAX;EACA,OAAK5F,UAAL,GAAkBA,UAAlB,CAJ6C;;EAO7C,OAAKyI,QAAL,GAAgB,CAAhB;EACA,OAAKC,SAAL,GAAiB,CAAjB;EACA,OAAKC,gBAAL,GAAwB,CAAxB;EACA,OAAKC,iBAAL,GAAyB,CAAzB;EACA,OAAKC,mBAAL,GAA2B,CAA3B,CAX6C;;EAc7C,eAAU,EAAV;EACA,OAAKjK,GAAL,GAAW,EAAX;EACA,OAAKC,UAAL,GAAkB,EAAlB;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASiK,gBAAT,CAA0BlD,GAA1B,EAA+B5F,UAA/B,EAA2C;EAEhD;EACA,OAAK4F,GAAL,GAAWA,GAAX;EACA,OAAK5F,UAAL,GAAkBA,UAAlB,CAJgD;;EAOhD,OAAKyI,QAAL,GAAgB,CAAhB;EACA,OAAKC,SAAL,GAAiB,CAAjB;EACA,OAAKE,iBAAL,GAAyB,CAAzB,CATgD;;EAYhD,eAAU,EAAV;EACA,OAAKhK,GAAL,GAAW,EAAX;EACD;;EAEDkK,gBAAgB,CAACnI,SAAjB,CAA2BoI,cAA3B,GAA4C,YAAW;EAErD;EACA,OAAKJ,gBAAL,GAAwB,CAAxB;EACA,OAAKE,mBAAL,GAA2B,CAA3B,CAJqD;;EAOrD,OAAKhK,UAAL,GAAkB,EAAlB;EACD,CARD;EAWA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACO,SAASmK,kBAAT,CAA4BpD,GAA5B,EAAiC5F,UAAjC,EAA6C;EAElD;EACA,OAAK4F,GAAL,GAAWA,GAAX;EACA,OAAK5F,UAAL,GAAkBA,UAAlB,CAJkD;;EAOlD,OAAK2I,gBAAL,GAAwB,CAAxB;EACA,OAAKE,mBAAL,GAA2B,CAA3B,CARkD;;EAWlD,OAAKhK,UAAL,GAAkB,EAAlB;EACD;;EAEDmK,kBAAkB,CAACrI,SAAnB,CAA6BoI,cAA7B,GAA8C,YAAW;EAEvD;EACA,OAAKN,QAAL,GAAgB,CAAhB;EACA,OAAKC,SAAL,GAAiB,CAAjB;EACA,OAAKE,iBAAL,GAAyB,CAAzB,CALuD;;EAQvD,eAAU,EAAV;EACA,OAAKhK,GAAL,GAAW,EAAX;EACD,CAVD;EAYA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACO,SAASqK,QAAT,CAAkBpK,UAAlB,EAA8B+G,GAA9B,EAAmCsD,YAAnC,EAAiD5K,MAAjD,EAAyDV,MAAzD,EAAiEoC,UAAjE,EAA6E;EAElF;EACA,OAAK4F,GAAL,GAAWA,GAAX;EACA,OAAK5F,UAAL,GAAkBA,UAAlB;EACA,OAAKnB,UAAL,GAAkBA,UAAlB,CALkF;;EAQlF,OAAKP,MAAL,GAAcA,MAAd;EACA,OAAKV,MAAL,GAAcA,MAAd,CATkF;;EAYlF,OAAKsL,YAAL,GAAoBA,YAApB;EACD;;EChID;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACO,SAASC,oBAAT,CACL9K,KADK,EAELQ,UAFK,EAGLuK,QAHK,EAIL9K,MAJK,EAKLV,MALK,EAMLY,UANK,EAOL6K,UAPK,EAQL;EACA,MAAMC,KAAK,GAAGjL,KAAK,CAACiL,KAApB;EAEA,MAAIC,MAAM,GAAG,KAAb;EACA,MAAIC,KAAK,GAAG,IAAZ;EAEA,MAAI3K,UAAJ,EACE0K,MAAM,GAAGC,KAAK,GAAG,YAAjB;EAEF,MAAIC,GAAJ,EAASC,SAAT;;EAEA,MAAIJ,KAAJ,EAAW;EAET;EACAG,IAAAA,GAAG,GAAGjL,UAAU,CAAC+K,MAAD,CAAhB;EACAG,IAAAA,SAAS,GAAGD,GAAG,CAAC7L,MAAD,CAAf;;EAEA,QAAI,OAAO8L,SAAP,KAAqB,WAAzB,EAAsC;EACpCA,MAAAA,SAAS,GAAG,IAAIC,GAAJ,EAAZ;EACAF,MAAAA,GAAG,CAAC7L,MAAD,CAAH,GAAc8L,SAAd;EACD;;EAEDA,IAAAA,SAAS,CAACE,GAAV,CAAcR,QAAd,EAXS;;EAcT,QAAI9K,MAAM,KAAKV,MAAX,IAAqBiB,UAAzB,EACE,OAfO;EAkBT;;EACA4K,IAAAA,GAAG,GAAGJ,UAAU,CAACG,KAAD,CAAhB;EACA,QAAI,OAAOC,GAAG,CAACnL,MAAD,CAAV,KAAuB,WAA3B,EACEmL,GAAG,CAACnL,MAAD,CAAH,GAAcoL,SAAd;EACH,GAtBD,MAuBK;EAEH;EACAlL,IAAAA,UAAU,CAAC+K,MAAD,CAAV,CAAmB3L,MAAnB,IAA6BwL,QAA7B,CAHG;;EAMH,QAAI9K,MAAM,KAAKV,MAAX,IAAqBiB,UAAzB,EACE,OAPC;;EAUHwK,IAAAA,UAAU,CAACG,KAAD,CAAV,CAAkBlL,MAAlB,IAA4B8K,QAA5B;EACD;EACF;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASS,2BAAT,CAAqCxL,KAArC,EAA4CQ,UAA5C,EAAwDuK,QAAxD,EAAkE;EACvE,MAAME,KAAK,GAAGjL,KAAK,CAACiL,KAApB;EAEA,MAAe9K,UAAf,GAAiD4K,QAAjD,CAAO9K,MAAP;EAAA,MAAmC+K,UAAnC,GAAiDD,QAAjD,CAA2BxL,MAA3B;EAEA,MAAMU,MAAM,GAAGE,UAAU,CAACoH,GAA1B;EAAA,MACMhI,MAAM,GAAGyL,UAAU,CAACzD,GAD1B,CALuE;EASvE;;EACA,MAAM2D,MAAM,GAAG1K,UAAU,GAAG,YAAH,GAAkB,KAA3C;EAAA,MACMiL,WAAW,GAAGtL,UAAU,CAAC+K,MAAD,CAD9B;EAGA,MAAMC,KAAK,GAAG3K,UAAU,GAAG,YAAH,GAAkB,IAA1C;;EAEA,MAAIjB,MAAM,IAAIkM,WAAd,EAA2B;EAEzB,QAAIR,KAAJ,EAAW;EACT,UAAMjH,GAAG,GAAGyH,WAAW,CAAClM,MAAD,CAAvB;;EAEA,UAAIyE,GAAG,CAAC0H,IAAJ,KAAa,CAAjB,EAAoB;EAClB,eAAOD,WAAW,CAAClM,MAAD,CAAlB;EACA,eAAOyL,UAAU,CAACG,KAAD,CAAV,CAAkBlL,MAAlB,CAAP;EACD,OAHD,MAIK;EACH+D,QAAAA,GAAG,UAAH,CAAW+G,QAAX;EACD;EACF,KAVD,MAYE,OAAOU,WAAW,CAAClM,MAAD,CAAlB;EACH;;EAED,MAAI0L,KAAJ,EACE;EAEF,MAAMU,WAAW,GAAGX,UAAU,CAACG,KAAD,CAA9B;EAEA,SAAOQ,WAAW,CAAC1L,MAAD,CAAlB;EACD;EAED;EACA;EACA;EACA;EACA;;EACO,SAAS2L,mBAAT,CAA6B5L,KAA7B,EAAoC;EACzCA,EAAAA,KAAK,CAACI,MAAN,CAAayL,OAAb,CAAqB,UAAA/B,IAAI,EAAI;EAE3B;EACA,QAAI,OAAOA,IAAI,MAAX,KAAmB,WAAvB,EAAoC;EAClCA,MAAAA,IAAI,MAAJ,GAAU,EAAV;EACAA,MAAAA,IAAI,CAACvJ,GAAL,GAAW,EAAX;EACD;;EAED,QAAI,OAAOuJ,IAAI,CAACtJ,UAAZ,KAA2B,WAA/B,EAA4C;EAC1CsJ,MAAAA,IAAI,CAACtJ,UAAL,GAAkB,EAAlB;EACD;EACF,GAXD;EAYD;EAED;EACA;EACA;EACA;EACA;;EACO,SAASsL,4BAAT,CAAsC9L,KAAtC,EAA6C;EAClDA,EAAAA,KAAK,CAACI,MAAN,CAAayL,OAAb,CAAqB,UAAC/B,IAAD,EAAOiC,IAAP,EAAgB;EAEnC;EACA,QAAIjC,IAAI,CAACvJ,GAAT,EAAc;EAEZ,WAAK,IAAMyL,QAAX,IAAuBlC,IAAI,CAACvJ,GAA5B,EAAiC;EAC/B,YAAM0L,KAAK,GAAG,IAAIX,GAAJ,EAAd;EACAW,QAAAA,KAAK,CAACV,GAAN,CAAUzB,IAAI,CAACvJ,GAAL,CAASyL,QAAT,CAAV;EACAlC,QAAAA,IAAI,CAACvJ,GAAL,CAASyL,QAAT,IAAqBC,KAArB;EACAjM,QAAAA,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiB2L,QAAjB,QAA8BD,IAA9B,IAAsCE,KAAtC;EACD;EACF,KAXkC;;;EAcnC,QAAInC,IAAI,CAACtJ,UAAT,EAAqB;EACnB,WAAK,IAAMwL,SAAX,IAAuBlC,IAAI,CAACtJ,UAA5B,EAAwC;EACtC,YAAIwL,SAAQ,GAAGD,IAAf,EACE;;EAEF,YAAME,MAAK,GAAG,IAAIX,GAAJ,EAAd;;EACAW,QAAAA,MAAK,CAACV,GAAN,CAAUzB,IAAI,CAACtJ,UAAL,CAAgBwL,SAAhB,CAAV;;EACAlC,QAAAA,IAAI,CAACtJ,UAAL,CAAgBwL,SAAhB,IAA4BC,MAA5B;EACAjM,QAAAA,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiB2L,SAAjB,EAA2BxL,UAA3B,CAAsCuL,IAAtC,IAA8CE,MAA9C;EACD;EACF;EACF,GAzBD;EA0BD;;EC3KD;EACA;EACA;EACA;EACA;EACA;EACA;EAaA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,SAASC,qBAAT,CAA+BC,KAA/B,EAAsCC,MAAtC,EAA8ClM,IAA9C,EAAoD;EAElD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkBnL,IAAlB,EAAwB;EAChD,QAAI4I,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAK2B,IADpB;EAGAA,MAAAA,IAAI,GAAG1B,SAAS,CAAC,CAAD,CAAhB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAdD,MAeK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAInM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF,WAAO4J,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,CAAP;EACD,GAjCD;EAkCD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASqL,sBAAT,CAAgCJ,KAAhC,EAAuCC,MAAvC,EAA+ClM,IAA/C,EAAqD;EAEnD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkB;EAC1C,QAAIvC,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAKC,SAAS,CAAC,CAAD,CAD7B;EAGAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAZD,MAaK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAInM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF,WAAO4J,IAAI,CAACnI,UAAZ;EACD,GA/BD;EAgCD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS6K,sBAAT,CAAgCL,KAAhC,EAAuCC,MAAvC,EAA+ClM,IAA/C,EAAqD;EAEnD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkBnL,IAAlB,EAAwB;EAChD,QAAI4I,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAK2B,IADpB;EAGAA,MAAAA,IAAI,GAAG1B,SAAS,CAAC,CAAD,CAAhB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAdD,MAeK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAInM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF,WAAO4J,IAAI,CAACnI,UAAL,CAAgB8K,cAAhB,CAA+BvL,IAA/B,CAAP;EACD,GAjCD;EAkCD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASwL,qBAAT,CAA+BP,KAA/B,EAAsCC,MAAtC,EAA8ClM,IAA9C,EAAoD;EAElD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkBnL,IAAlB,EAAwBR,KAAxB,EAA+B;EACvD,QAAIoJ,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAK2B,IADpB;EAGAA,MAAAA,IAAI,GAAG1B,SAAS,CAAC,CAAD,CAAhB;EACAkB,MAAAA,KAAK,GAAGlB,SAAS,CAAC,CAAD,CAAjB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAfD,MAgBK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAInM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF4J,IAAAA,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,IAAwBR,KAAxB,CAjCuD;;EAoCvD,SAAKgE,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEuC,IAAI,CAACvC,GADuB;EAEjCrH,MAAAA,IAAI,EAAE,KAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD,GA5CD;EA6CD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASyL,sBAAT,CAAgCR,KAAhC,EAAuCC,MAAvC,EAA+ClM,IAA/C,EAAqD;EAEnD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkBnL,IAAlB,EAAwB0L,OAAxB,EAAiC;EACzD,QAAI9C,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAK2B,IADpB;EAGAA,MAAAA,IAAI,GAAG1B,SAAS,CAAC,CAAD,CAAhB;EACAoN,MAAAA,OAAO,GAAGpN,SAAS,CAAC,CAAD,CAAnB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAfD,MAgBK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAI,OAAOO,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAI7C,0BAAJ,iBAAwCqC,MAAxC,qCAAN;EAEF,QAAIlM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF4J,IAAAA,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,IAAwB0L,OAAO,CAAC9C,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,CAAD,CAA/B,CApCyD;;EAuCzD,SAAKwD,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEuC,IAAI,CAACvC,GADuB;EAEjCrH,MAAAA,IAAI,EAAE,KAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD,GA/CD;EAgDD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS2L,sBAAT,CAAgCV,KAAhC,EAAuCC,MAAvC,EAA+ClM,IAA/C,EAAqD;EAEnD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkBnL,IAAlB,EAAwB;EAChD,QAAI4I,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAK2B,IADpB;EAGAA,MAAAA,IAAI,GAAG1B,SAAS,CAAC,CAAD,CAAhB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAdD,MAeK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAInM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF,WAAO4J,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,CAAP,CAhCgD;;EAmChD,SAAKwD,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEuC,IAAI,CAACvC,GADuB;EAEjCrH,MAAAA,IAAI,EAAE,QAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD,GA3CD;EA4CD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS4L,wBAAT,CAAkCX,KAAlC,EAAyCC,MAAzC,EAAiDlM,IAAjD,EAAuD;EAErD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkB1K,UAAlB,EAA8B;EACtD,QAAImI,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAKoC,UADpB;EAGAA,MAAAA,UAAU,GAAGnC,SAAS,CAAC,CAAD,CAAtB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAdD,MAeK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAI,CAACxL,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,iBAAwCqC,MAAxC,mDAAN;EAEF,QAAIlM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEF4J,IAAAA,IAAI,CAACnI,UAAL,GAAkBA,UAAlB,CAnCsD;;EAsCtD,SAAK+C,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEuC,IAAI,CAACvC,GADuB;EAEjCrH,MAAAA,IAAI,EAAE,SAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI;EAHgB,KAAnC;EAMA,WAAO,IAAP;EACD,GA7CD;EA8CD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASoL,sBAAT,CAAgCZ,KAAhC,EAAuCC,MAAvC,EAA+ClM,IAA/C,EAAqD;EAEnD;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACEiM,EAAAA,KAAK,CAAC7J,SAAN,CAAgB8J,MAAhB,IAA0B,UAASC,OAAT,EAAkB1K,UAAlB,EAA8B;EACtD,QAAImI,IAAJ;EAEA,QAAI,KAAK5J,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIgK,eAAJ,iBAA6BkC,MAA7B,sDAA+E,KAAKlM,IAApF,aAAN;;EAEF,QAAIV,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EAExB,UAAI,KAAKsL,KAAT,EACE,MAAM,IAAIf,eAAJ,iBAA6BkC,MAA7B,2JAAN;EAEF,UAAMnM,MAAM,GAAG,KAAKoM,OAApB;EAAA,UACM9M,MAAM,GAAG,KAAKoC,UADpB;EAGAA,MAAAA,UAAU,GAAGnC,SAAS,CAAC,CAAD,CAAtB;EAEAsK,MAAAA,IAAI,GAAG/J,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuBW,IAAvB,CAAtB;EAEA,UAAI,CAAC4J,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,4DAAuFnM,MAAvF,oBAAqGV,MAArG,UAAN;EACH,KAdD,MAeK;EACH8M,MAAAA,OAAO,GAAG,KAAKA,OAAf;EACAvC,MAAAA,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBgM,OAAhB,CAAP;EAEA,UAAI,CAACvC,IAAL,EACE,MAAM,IAAIG,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,2BAAN;EACH;;EAED,QAAI,CAACxL,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,iBAAwCqC,MAAxC,mDAAN;EAEF,QAAIlM,IAAI,KAAK,OAAT,IAAoB4J,IAAI,CAACtJ,UAAL,MAAqBN,IAAI,KAAK,YAA9B,CAAxB,EACE,MAAM,IAAI+J,kBAAJ,iBAAgCmC,MAAhC,oCAA+DC,OAA/D,gBAA2EnM,IAA3E,yBAAN;EAEFL,IAAAA,MAAM,CAACiK,IAAI,CAACnI,UAAN,EAAkBA,UAAlB,CAAN,CAnCsD;;EAsCtD,SAAK+C,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEuC,IAAI,CAACvC,GADuB;EAEjCrH,MAAAA,IAAI,EAAE,OAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCmI,MAAAA,IAAI,EAAEnI;EAJ2B,KAAnC;EAOA,WAAO,IAAP;EACD,GA9CD;EA+CD;EAED;EACA;EACA;;;EACA,IAAMqL,kBAAkB,GAAG,CACzB;EACE9L,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,wBAAUA,OAAV;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEf;EAFZ,CADyB,EAKzB;EACEhL,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,wBAAUA,OAAV;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEV;EAFZ,CALyB,EASzB;EACErL,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,wBAAUA,OAAV;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAET;EAFZ,CATyB,EAazB;EACEtL,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,wBAAUA,OAAV;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEP;EAFZ,CAbyB,EAiBzB;EACExL,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,2BAAaA,OAAb;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEN;EAFZ,CAjByB,EAqBzB;EACEzL,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,2BAAaA,OAAb;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEJ;EAFZ,CArByB,EAyBzB;EACE3L,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,4BAAcA,OAAd;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEH;EAFZ,CAzByB,EA6BzB;EACE5L,EAAAA,IAAI,EAAE,cAAAmL,OAAO;EAAA,0BAAYA,OAAZ;EAAA,GADf;EAEEY,EAAAA,QAAQ,EAAEF;EAFZ,CA7ByB,CAA3B;EAmCA;EACA;EACA;EACA;EACA;;EACO,SAASG,uBAAT,CAAiCC,KAAjC,EAAwC;EAC7CH,EAAAA,kBAAkB,CAACnB,OAAnB,CAA2B,gBAA2B;EAAA,QAAjB3K,IAAiB,QAAjBA,IAAiB;EAAA,QAAX+L,QAAW,QAAXA,QAAW;EAEpD;EACAA,IAAAA,QAAQ,CACNE,KADM,EAENjM,IAAI,CAAC,MAAD,CAFE,EAGN,OAHM,CAAR,CAHoD;;EAUpD+L,IAAAA,QAAQ,CACNE,KADM,EAENjM,IAAI,CAAC,cAAD,CAFE,EAGN,UAHM,CAAR,CAVoD;;EAiBpD+L,IAAAA,QAAQ,CACNE,KADM,EAENjM,IAAI,CAAC,gBAAD,CAFE,EAGN,YAHM,CAAR;EAKD,GAtBD;EAuBD;;;;;;;;EC7nBD,IAAI8H,QAAQ,GAAGoE,QAAf;EAEA;EACA;EACA;EACA;EACA;EACA;;MACAC,KAAc,GAAG,SAASA,KAAT,GAAiB;EAChC,MAAIC,SAAS,GAAG9N,SAAhB;EAAA,MACI+N,OADJ;EAAA,MAEI9N,CAAC,GAAG,CAAC,CAFT;EAIA,SAAO,IAAIuJ,QAAJ,CAAa,SAASwE,OAAT,GAAmB;EACrC,QAAI,CAACD,OAAL,EAAc;EACZ9N,MAAAA,CAAC;EAED,UAAIA,CAAC,IAAI6N,SAAS,CAAC3N,MAAnB,EACE,OAAO;EAACuJ,QAAAA,IAAI,EAAE;EAAP,OAAP;EAEFqE,MAAAA,OAAO,GAAGD,SAAS,CAAC7N,CAAD,CAAnB;EACD;;EAED,QAAI0J,IAAI,GAAGoE,OAAO,CAACtE,IAAR,EAAX;;EAEA,QAAIE,IAAI,CAACD,IAAT,EAAe;EACbqE,MAAAA,OAAO,GAAG,IAAV;EACA,aAAOC,OAAO,EAAd;EACD;;EAED,WAAOrE,IAAP;EACD,GAlBM,CAAP;EAmBD;;ECtCD;EACA;EACA;EACA;EACA;EACA;EACA;EAUA;EACA;EACA;;EACA,IAAMsE,eAAe,GAAG,CACtB;EACEvM,EAAAA,IAAI,EAAE,OADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CADsB,EAKtB;EACEgB,EAAAA,IAAI,EAAE,SADR;EAEEhB,EAAAA,IAAI,EAAE,UAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CALsB,EAUtB;EACExM,EAAAA,IAAI,EAAE,UADR;EAEEhB,EAAAA,IAAI,EAAE,UAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CAVsB,EAetB;EACExM,EAAAA,IAAI,EAAE,cADR;EAEEhB,EAAAA,IAAI,EAAE,OAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CAfsB,EAoBtB;EACExM,EAAAA,IAAI,EAAE,eADR;EAEEhB,EAAAA,IAAI,EAAE,OAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CApBsB,EAyBtB;EACExM,EAAAA,IAAI,EAAE,eADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CAzBsB,EA6BtB;EACEgB,EAAAA,IAAI,EAAE,iBADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CA7BsB,CAAxB;EAmCA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,SAASyN,aAAT,CAAuB1B,KAAvB,EAA8B2B,MAA9B,EAAsC;EACpC,OAAK,IAAMhO,CAAX,IAAgBgO,MAAhB;EACE3B,IAAAA,KAAK,CAACtH,IAAN,CAAWiJ,MAAM,CAAChO,CAAD,CAAN,CAAU2H,GAArB;EADF;EAED;;EAED,SAASsG,YAAT,CAAsB5B,KAAtB,EAA6B2B,MAA7B,EAAqC;EACnC,OAAK,IAAMhO,CAAX,IAAgBgO,MAAhB;EACEA,IAAAA,MAAM,CAAChO,CAAD,CAAN,CAAUiM,OAAV,CAAkB,UAAAd,QAAQ;EAAA,aAAIkB,KAAK,CAACtH,IAAN,CAAWoG,QAAQ,CAACxD,GAApB,CAAJ;EAAA,KAA1B;EADF;EAED;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASuG,aAAT,CAAuBF,MAAvB,EAA+BG,QAA/B,EAAyCC,KAAzC,EAAgD;EAC9C,OAAK,IAAMpO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAIhO,CAAC,KAAKoO,KAAV,EACE;EAEF,QAAMjD,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAvB;EAEAmO,IAAAA,QAAQ,CACNhD,QAAQ,CAACxD,GADH,EAENwD,QAAQ,CAACpJ,UAFH,EAGNoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHV,EAINwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJV,EAKNwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALV,EAMNoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANV,EAONoJ,QAAQ,CAACvK,UAPH,EAQNuK,QAAQ,CAACF,YARH,CAAR;EAUD;EACF;;EAED,SAASoD,YAAT,CAAsBL,MAAtB,EAA8BG,QAA9B,EAAwCC,KAAxC,EAA+C;EAC7C,OAAK,IAAMpO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAIhO,CAAC,KAAKoO,KAAV,EACE;EAEFJ,IAAAA,MAAM,CAAChO,CAAD,CAAN,CAAUiM,OAAV,CAAkB,UAAAd,QAAQ;EAAA,aAAIgD,QAAQ,CACpChD,QAAQ,CAACxD,GAD2B,EAEpCwD,QAAQ,CAACpJ,UAF2B,EAGpCoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHoB,EAIpCwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJoB,EAKpCwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALoB,EAMpCoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANoB,EAOpCoJ,QAAQ,CAACvK,UAP2B,EAQpCuK,QAAQ,CAACF,YAR2B,CAAZ;EAAA,KAA1B;EAUD;EACF;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASqD,kBAAT,CAA4BN,MAA5B,EAAoCG,QAApC,EAA8CC,KAA9C,EAAqD;EACnD,MAAIG,WAAW,GAAG,KAAlB;;EAEA,OAAK,IAAMvO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAIhO,CAAC,KAAKoO,KAAV,EACE;EAEF,QAAMjD,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAvB;EAEAuO,IAAAA,WAAW,GAAGJ,QAAQ,CACpBhD,QAAQ,CAACxD,GADW,EAEpBwD,QAAQ,CAACpJ,UAFW,EAGpBoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHI,EAIpBwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJI,EAKpBwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALI,EAMpBoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANI,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,QAAIsD,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;;EAED,SAASC,iBAAT,CAA2BR,MAA3B,EAAmCG,QAAnC,EAA6CC,KAA7C,EAAoD;EAClD,MAAI1E,QAAJ,EAAcH,IAAd,EAAoB4B,QAApB,EAA8B9K,MAA9B,EAAsCV,MAAtC;EAEA,MAAI4O,WAAW,GAAG,KAAlB;;EAEA,OAAK,IAAMvO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAIhO,CAAC,KAAKoO,KAAV,EACE;EAEF1E,IAAAA,QAAQ,GAAGsE,MAAM,CAAChO,CAAD,CAAN,CAAUyO,MAAV,EAAX;;EAEA,WAAQlF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnD6B,MAAAA,QAAQ,GAAG5B,IAAI,CAACzI,KAAhB;EACAT,MAAAA,MAAM,GAAG8K,QAAQ,CAAC9K,MAAlB;EACAV,MAAAA,MAAM,GAAGwL,QAAQ,CAACxL,MAAlB;EAEA4O,MAAAA,WAAW,GAAGJ,QAAQ,CACpBhD,QAAQ,CAACxD,GADW,EAEpBwD,QAAQ,CAACpJ,UAFW,EAGpB1B,MAAM,CAACsH,GAHa,EAIpBhI,MAAM,CAACgI,GAJa,EAKpBtH,MAAM,CAAC0B,UALa,EAMpBpC,MAAM,CAACoC,UANa,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,UAAIsD,WAAJ,EACE,OAAO,IAAP;EACH;EACF;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASG,cAAT,CAAwBV,MAAxB,EAAgCI,KAAhC,EAAuC;EACrC,MAAM1G,IAAI,GAAGxH,MAAM,CAACwH,IAAP,CAAYsG,MAAZ,CAAb;EAAA,MACMlO,CAAC,GAAG4H,IAAI,CAAC3H,MADf;EAGA,MAAI4O,KAAK,GAAG,IAAZ;EAAA,MACI9O,CAAC,GAAG,CADR;EAGA,SAAO,IAAIuJ,QAAJ,CAAa,SAASC,IAAT,GAAgB;EAClC,QAAI8B,QAAJ;;EAEA,QAAIwD,KAAJ,EAAW;EACT,UAAMpF,IAAI,GAAGoF,KAAK,CAACtF,IAAN,EAAb;;EAEA,UAAIE,IAAI,CAACD,IAAT,EAAe;EACbqF,QAAAA,KAAK,GAAG,IAAR;EACA9O,QAAAA,CAAC;EACD,eAAOwJ,IAAI,EAAX;EACD;;EAED8B,MAAAA,QAAQ,GAAG5B,IAAI,CAACzI,KAAhB;EACD,KAVD,MAWK;EACH,UAAIjB,CAAC,IAAIC,CAAT,EACE,OAAO;EAACwJ,QAAAA,IAAI,EAAE;EAAP,OAAP;EAEF,UAAMtJ,CAAC,GAAG0H,IAAI,CAAC7H,CAAD,CAAd;;EAEA,UAAIG,CAAC,KAAKoO,KAAV,EAAiB;EACfvO,QAAAA,CAAC;EACD,eAAOwJ,IAAI,EAAX;EACD;;EAED8B,MAAAA,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAjB;;EAEA,UAAImL,QAAQ,YAAYO,GAAxB,EAA6B;EAC3BiD,QAAAA,KAAK,GAAGxD,QAAQ,CAACsD,MAAT,EAAR;EACA,eAAOpF,IAAI,EAAX;EACD;;EAEDxJ,MAAAA,CAAC;EACF;;EAED,WAAO;EACLyJ,MAAAA,IAAI,EAAE,KADD;EAELxI,MAAAA,KAAK,EAAE,CACLqK,QAAQ,CAACxD,GADJ,EAELwD,QAAQ,CAACpJ,UAFJ,EAGLoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHX,EAILwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJX,EAKLwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALX,EAMLoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANX;EAFF,KAAP;EAWD,GA9CM,CAAP;EA+CD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS6M,mBAAT,CAA6BvC,KAA7B,EAAoC2B,MAApC,EAA4ChO,CAA5C,EAA+C;EAC7C,MAAMmL,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAvB;EAEA,MAAI,CAACmL,QAAL,EACE;EAEFkB,EAAAA,KAAK,CAACtH,IAAN,CAAWoG,QAAQ,CAACxD,GAApB;EACD;;EAED,SAASkH,kBAAT,CAA4BxC,KAA5B,EAAmC2B,MAAnC,EAA2ChO,CAA3C,EAA8C;EAC5C,MAAM8O,SAAS,GAAGd,MAAM,CAAChO,CAAD,CAAxB;EAEA,MAAI,CAAC8O,SAAL,EACE;EAEFA,EAAAA,SAAS,CAAC7C,OAAV,CAAkB,UAAAd,QAAQ;EAAA,WAAIkB,KAAK,CAACtH,IAAN,CAAWoG,QAAQ,CAACxD,GAApB,CAAJ;EAAA,GAA1B;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASoH,mBAAT,CAA6Bf,MAA7B,EAAqChO,CAArC,EAAwCmO,QAAxC,EAAkD;EAChD,MAAMhD,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAvB;EAEA,MAAI,CAACmL,QAAL,EACE;EAEF,MAAM5K,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EACA,MAAM+K,UAAU,GAAGD,QAAQ,CAACxL,MAA5B;EAEAwO,EAAAA,QAAQ,CACNhD,QAAQ,CAACxD,GADH,EAENwD,QAAQ,CAACpJ,UAFH,EAGNxB,UAAU,CAACoH,GAHL,EAINyD,UAAU,CAACzD,GAJL,EAKNpH,UAAU,CAACwB,UALL,EAMNqJ,UAAU,CAACrJ,UANL,EAONoJ,QAAQ,CAACvK,UAPH,EAQNuK,QAAQ,CAACF,YARH,CAAR;EAUD;;EAED,SAAS+D,kBAAT,CAA4BhB,MAA5B,EAAoChO,CAApC,EAAuCmO,QAAvC,EAAiD;EAC/C,MAAMW,SAAS,GAAGd,MAAM,CAAChO,CAAD,CAAxB;EAEA,MAAI,CAAC8O,SAAL,EACE;EAEFA,EAAAA,SAAS,CAAC7C,OAAV,CAAkB,UAAAd,QAAQ;EAAA,WAAIgD,QAAQ,CACpChD,QAAQ,CAACxD,GAD2B,EAEpCwD,QAAQ,CAACpJ,UAF2B,EAGpCoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHoB,EAIpCwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJoB,EAKpCwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALoB,EAMpCoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANoB,EAOpCoJ,QAAQ,CAACvK,UAP2B,EAQpCuK,QAAQ,CAACF,YAR2B,CAAZ;EAAA,GAA1B;EAUD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASgE,wBAAT,CAAkCjB,MAAlC,EAA0ChO,CAA1C,EAA6CmO,QAA7C,EAAuD;EACrD,MAAMhD,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAAvB;EAEA,MAAI,CAACmL,QAAL,EACE,OAAO,KAAP;EAEF,MAAM5K,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EACA,MAAM+K,UAAU,GAAGD,QAAQ,CAACxL,MAA5B;EAEA,SAAOwO,QAAQ,CACbhD,QAAQ,CAACxD,GADI,EAEbwD,QAAQ,CAACpJ,UAFI,EAGbxB,UAAU,CAACoH,GAHE,EAIbyD,UAAU,CAACzD,GAJE,EAKbpH,UAAU,CAACwB,UALE,EAMbqJ,UAAU,CAACrJ,UANE,EAOboJ,QAAQ,CAACvK,UAPI,EAQbuK,QAAQ,CAACF,YARI,CAAf;EAUD;;EAED,SAASiE,uBAAT,CAAiClB,MAAjC,EAAyChO,CAAzC,EAA4CmO,QAA5C,EAAsD;EACpD,MAAMW,SAAS,GAAGd,MAAM,CAAChO,CAAD,CAAxB;EAEA,MAAI,CAAC8O,SAAL,EACE,OAAO,KAAP;EAEF,MAAIP,WAAW,GAAG,KAAlB;EAEA,MAAM7E,QAAQ,GAAGoF,SAAS,CAACL,MAAV,EAAjB;EACA,MAAIlF,IAAJ,EAAU4B,QAAV;;EAEA,SAAQ5B,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnD6B,IAAAA,QAAQ,GAAG5B,IAAI,CAACzI,KAAhB;EAEAyN,IAAAA,WAAW,GAAGJ,QAAQ,CACpBhD,QAAQ,CAACxD,GADW,EAEpBwD,QAAQ,CAACpJ,UAFW,EAGpBoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHI,EAIpBwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJI,EAKpBwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALI,EAMpBoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANI,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,QAAIsD,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASY,oBAAT,CAA8BnB,MAA9B,EAAsChO,CAAtC,EAAyC;EACvC,MAAMoP,CAAC,GAAGpB,MAAM,CAAChO,CAAD,CAAhB;;EAEA,MAAIoP,CAAC,YAAY1D,GAAjB,EAAsB;EACpB,QAAMhC,UAAQ,GAAG0F,CAAC,CAACX,MAAF,EAAjB;EAEA,WAAO,IAAIrF,QAAJ,CAAa,YAAW;EAC7B,UAAMG,IAAI,GAAGG,UAAQ,CAACL,IAAT,EAAb;EAEA,UAAIE,IAAI,CAACD,IAAT,EACE,OAAOC,IAAP;EAEF,UAAM4B,QAAQ,GAAG5B,IAAI,CAACzI,KAAtB;EAEA,aAAO;EACLwI,QAAAA,IAAI,EAAE,KADD;EAELxI,QAAAA,KAAK,EAAE,CACLqK,QAAQ,CAACxD,GADJ,EAELwD,QAAQ,CAACpJ,UAFJ,EAGLoJ,QAAQ,CAAC9K,MAAT,CAAgBsH,GAHX,EAILwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAJX,EAKLwD,QAAQ,CAAC9K,MAAT,CAAgB0B,UALX,EAMLoJ,QAAQ,CAACxL,MAAT,CAAgBoC,UANX;EAFF,OAAP;EAWD,KAnBM,CAAP;EAoBD;;EAED,SAAOqH,QAAQ,CAACO,EAAT,CAAY,CACjByF,CAAC,CAACzH,GADe,EAEjByH,CAAC,CAACrN,UAFe,EAGjBqN,CAAC,CAAC/O,MAAF,CAASsH,GAHQ,EAIjByH,CAAC,CAACzP,MAAF,CAASgI,GAJQ,EAKjByH,CAAC,CAAC/O,MAAF,CAAS0B,UALQ,EAMjBqN,CAAC,CAACzP,MAAF,CAASoC,UANQ,CAAZ,CAAP;EAQD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASsN,eAAT,CAAyBjP,KAAzB,EAAgCE,IAAhC,EAAsC;EACpC,MAAIF,KAAK,CAAC0L,IAAN,KAAe,CAAnB,EACE,OAAO,EAAP;;EAEF,MAAIxL,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAvC,EAA6C;EAC3C,QAAI,OAAO0B,KAAK,CAACsN,IAAb,KAAsB,UAA1B,EACE,OAAOtN,KAAK,CAACsN,IAAN,CAAWlP,KAAK,CAACsM,MAAN,CAAahF,IAAb,EAAX,CAAP;EAEF,WAAOoC,IAAI,CAAC1J,KAAK,CAACsM,MAAN,CAAahF,IAAb,EAAD,EAAsBtH,KAAK,CAACsM,MAAN,CAAaZ,IAAnC,CAAX;EACD;;EAED,MAAMA,IAAI,GAAGxL,IAAI,KAAK,YAAT,GACXF,KAAK,CAACmP,cADK,GAEXnP,KAAK,CAACoP,YAFR;EAIA,MAAMrI,IAAI,GAAG,IAAInF,KAAJ,CAAU8J,IAAV,CAAb;EAAA,MACM2D,IAAI,GAAGnP,IAAI,KAAK,YADtB;;EAGA,MAAMoJ,QAAQ,GAAGtJ,KAAK,CAACsM,MAAN,CAAa+B,MAAb,EAAjB;;EAEA,MAAI5O,CAAC,GAAG,CAAR;EACA,MAAI0J,IAAJ,EAAUW,IAAV;;EAEA,SAAQX,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnDY,IAAAA,IAAI,GAAGX,IAAI,CAACzI,KAAZ;EAEA,QAAIoJ,IAAI,CAACtJ,UAAL,KAAoB6O,IAAxB,EACEtI,IAAI,CAACtH,CAAC,EAAF,CAAJ,GAAYqK,IAAI,CAACvC,GAAjB;EACH;;EAED,SAAOR,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASuI,WAAT,CAAqBtP,KAArB,EAA4BE,IAA5B,EAAkC6N,QAAlC,EAA4C;EAC1C,MAAI/N,KAAK,CAAC0L,IAAN,KAAe,CAAnB,EACE;EAEF,MAAM6D,YAAY,GAAGrP,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAxD;EACA,MAAMmP,IAAI,GAAGnP,IAAI,KAAK,YAAtB;EAEA,MAAIiJ,IAAJ,EAAUW,IAAV;;EACA,MAAMR,QAAQ,GAAGtJ,KAAK,CAACsM,MAAN,CAAa+B,MAAb,EAAjB;;EAEA,SAAQlF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnDY,IAAAA,IAAI,GAAGX,IAAI,CAACzI,KAAZ;EAEA,QAAI6O,YAAY,IAAIzF,IAAI,CAACtJ,UAAL,KAAoB6O,IAAxC,EACE;EAEF,gBAA0CvF,IAA1C;EAAA,QAAOvC,GAAP,SAAOA,GAAP;EAAA,QAAY5F,UAAZ,SAAYA,UAAZ;EAAA,QAAwB1B,MAAxB,SAAwBA,MAAxB;EAAA,QAAgCV,MAAhC,SAAgCA,MAAhC;EAEAwO,IAAAA,QAAQ,CACNxG,GADM,EAEN5F,UAFM,EAGN1B,MAAM,CAACsH,GAHD,EAINhI,MAAM,CAACgI,GAJD,EAKNtH,MAAM,CAAC0B,UALD,EAMNpC,MAAM,CAACoC,UAND,EAONmI,IAAI,CAACtJ,UAPC,EAQNsJ,IAAI,CAACe,YARC,CAAR;EAUD;EACF;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS2E,gBAAT,CAA0BxP,KAA1B,EAAiCE,IAAjC,EAAuC6N,QAAvC,EAAiD;EAC/C,MAAI/N,KAAK,CAAC0L,IAAN,KAAe,CAAnB,EACE,OAAO,KAAP;EAEF,MAAM6D,YAAY,GAAGrP,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAxD;EACA,MAAMmP,IAAI,GAAGnP,IAAI,KAAK,YAAtB;EAEA,MAAIiJ,IAAJ,EAAUW,IAAV;EACA,MAAIqE,WAAW,GAAG,KAAlB;;EACA,MAAM7E,QAAQ,GAAGtJ,KAAK,CAACsM,MAAN,CAAa+B,MAAb,EAAjB;;EAEA,SAAQlF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnDY,IAAAA,IAAI,GAAGX,IAAI,CAACzI,KAAZ;EAEA,QAAI6O,YAAY,IAAIzF,IAAI,CAACtJ,UAAL,KAAoB6O,IAAxC,EACE;EAEF,iBAA0CvF,IAA1C;EAAA,QAAOvC,GAAP,UAAOA,GAAP;EAAA,QAAY5F,UAAZ,UAAYA,UAAZ;EAAA,QAAwB1B,MAAxB,UAAwBA,MAAxB;EAAA,QAAgCV,MAAhC,UAAgCA,MAAhC;EAEA4O,IAAAA,WAAW,GAAGJ,QAAQ,CACpBxG,GADoB,EAEpB5F,UAFoB,EAGpB1B,MAAM,CAACsH,GAHa,EAIpBhI,MAAM,CAACgI,GAJa,EAKpBtH,MAAM,CAAC0B,UALa,EAMpBpC,MAAM,CAACoC,UANa,EAOpBmI,IAAI,CAACtJ,UAPe,EAQpBsJ,IAAI,CAACe,YARe,CAAtB;EAWA,QAAIsD,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASsB,kBAAT,CAA4BzP,KAA5B,EAAmCE,IAAnC,EAAyC;EACvC,MAAIF,KAAK,CAAC0L,IAAN,KAAe,CAAnB,EACE,OAAO1C,QAAQ,CAACQ,KAAT,EAAP;EAEF,MAAM+F,YAAY,GAAGrP,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAxD;EACA,MAAMmP,IAAI,GAAGnP,IAAI,KAAK,YAAtB;;EAEA,MAAMoJ,UAAQ,GAAGtJ,KAAK,CAACsM,MAAN,CAAa+B,MAAb,EAAjB;;EAEA,SAAO,IAAIrF,QAAJ,CAAa,SAASC,IAAT,GAAgB;EAClC,QAAIE,IAAJ,EAAUW,IAAV,CADkC;;EAIlC,WAAO,IAAP,EAAa;EACXX,MAAAA,IAAI,GAAGG,UAAQ,CAACL,IAAT,EAAP;EAEA,UAAIE,IAAI,CAACD,IAAT,EACE,OAAOC,IAAP;EAEFW,MAAAA,IAAI,GAAGX,IAAI,CAACzI,KAAZ;EAEA,UAAI6O,YAAY,IAAIzF,IAAI,CAACtJ,UAAL,KAAoB6O,IAAxC,EACE;EAEF;EACD;;EAED,QAAM3O,KAAK,GAAG,CACZoJ,IAAI,CAACvC,GADO,EAEZuC,IAAI,CAACnI,UAFO,EAGZmI,IAAI,CAAC7J,MAAL,CAAYsH,GAHA,EAIZuC,IAAI,CAACvK,MAAL,CAAYgI,GAJA,EAKZuC,IAAI,CAAC7J,MAAL,CAAY0B,UALA,EAMZmI,IAAI,CAACvK,MAAL,CAAYoC,UANA,CAAd;EASA,WAAO;EAACjB,MAAAA,KAAK,EAALA,KAAD;EAAQwI,MAAAA,IAAI,EAAE;EAAd,KAAP;EACD,GA5BM,CAAP;EA6BD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASwG,sBAAT,CAAgCzE,KAAhC,EAAuC/K,IAAvC,EAA6CwN,SAA7C,EAAwDiC,QAAxD,EAAkE;EAChE,MAAM1D,KAAK,GAAG,EAAd;EAEA,MAAM2D,EAAE,GAAG3E,KAAK,GAAG4C,YAAH,GAAkBF,aAAlC;;EAEA,MAAIzN,IAAI,KAAK,YAAb,EAA2B;EACzB,QAAIwN,SAAS,KAAK,KAAlB,EACEkC,EAAE,CAAC3D,KAAD,EAAQ0D,QAAQ,MAAhB,CAAF;EACF,QAAIjC,SAAS,KAAK,IAAlB,EACEkC,EAAE,CAAC3D,KAAD,EAAQ0D,QAAQ,CAACpP,GAAjB,CAAF,CAJuB;;EAOzB,QAAI,CAACmN,SAAD,IAAciC,QAAQ,CAACpF,iBAAT,GAA6B,CAA/C,EACE0B,KAAK,CAAC4D,MAAN,CAAa5D,KAAK,CAAC6D,WAAN,CAAkBH,QAAQ,CAACpI,GAA3B,CAAb,EAA8C,CAA9C;EACH;;EAED,MAAIrH,IAAI,KAAK,UAAb,EAAyB;EACvB0P,IAAAA,EAAE,CAAC3D,KAAD,EAAQ0D,QAAQ,CAACnP,UAAjB,CAAF;EACD;;EAED,SAAOyL,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS8D,kBAAT,CAA4B9E,KAA5B,EAAmC/K,IAAnC,EAAyCwN,SAAzC,EAAoDiC,QAApD,EAA8D5B,QAA9D,EAAwE;EACtE,MAAM6B,EAAE,GAAG3E,KAAK,GAAGgD,YAAH,GAAkBH,aAAlC;;EAEA,MAAI5N,IAAI,KAAK,YAAb,EAA2B;EACzB,QAAIwN,SAAS,KAAK,KAAlB,EACEkC,EAAE,CAACD,QAAQ,MAAT,EAAc5B,QAAd,CAAF;EACF,QAAIL,SAAS,KAAK,IAAlB,EACEkC,EAAE,CAACD,QAAQ,CAACpP,GAAV,EAAewN,QAAf,EAAyB,CAACL,SAAD,GAAaiC,QAAQ,CAACpI,GAAtB,GAA4B,IAArD,CAAF;EACH;;EAED,MAAIrH,IAAI,KAAK,UAAb,EAAyB;EACvB0P,IAAAA,EAAE,CAACD,QAAQ,CAACnP,UAAV,EAAsBuN,QAAtB,CAAF;EACD;EACF;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASiC,uBAAT,CAAiC/E,KAAjC,EAAwC/K,IAAxC,EAA8CwN,SAA9C,EAAyDiC,QAAzD,EAAmE5B,QAAnE,EAA6E;EAC3E,MAAM6B,EAAE,GAAG3E,KAAK,GAAGmD,iBAAH,GAAuBF,kBAAvC;EAEA,MAAIC,WAAW,GAAG,KAAlB;;EAEA,MAAIjO,IAAI,KAAK,YAAb,EAA2B;EACzB,QAAIwN,SAAS,KAAK,KAAlB,EAAyB;EACvBS,MAAAA,WAAW,GAAGyB,EAAE,CAACD,QAAQ,MAAT,EAAc5B,QAAd,CAAhB;EAEA,UAAII,WAAJ,EACE,OAAO,IAAP;EACH;;EACD,QAAIT,SAAS,KAAK,IAAlB,EAAwB;EACtBS,MAAAA,WAAW,GAAGyB,EAAE,CAACD,QAAQ,CAACpP,GAAV,EAAewN,QAAf,EAAyB,CAACL,SAAD,GAAaiC,QAAQ,CAACpI,GAAtB,GAA4B,IAArD,CAAhB;EAEA,UAAI4G,WAAJ,EACE,OAAO,IAAP;EACH;EACF;;EAED,MAAIjO,IAAI,KAAK,UAAb,EAAyB;EACvBiO,IAAAA,WAAW,GAAGyB,EAAE,CAACD,QAAQ,CAACnP,UAAV,EAAsBuN,QAAtB,CAAhB;EAEA,QAAII,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS8B,yBAAT,CAAmC/P,IAAnC,EAAyCwN,SAAzC,EAAoDiC,QAApD,EAA8D;EAC5D,MAAIrG,UAAQ,GAAGN,QAAQ,CAACQ,KAAT,EAAf;;EAEA,MAAItJ,IAAI,KAAK,YAAb,EAA2B;EACzB,QAAIwN,SAAS,KAAK,KAAd,IAAuB,OAAOiC,QAAQ,MAAf,KAAuB,WAAlD,EACErG,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWgF,cAAc,CAACqB,QAAQ,MAAT,CAAzB,CAAhB;EACF,QAAIjC,SAAS,KAAK,IAAd,IAAsB,OAAOiC,QAAQ,CAACpP,GAAhB,KAAwB,WAAlD,EACE+I,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWgF,cAAc,CAACqB,QAAQ,CAACpP,GAAV,EAAe,CAACmN,SAAD,GAAaiC,QAAQ,CAACpI,GAAtB,GAA4B,IAA3C,CAAzB,CAAhB;EACH;;EAED,MAAIrH,IAAI,KAAK,UAAT,IAAuB,OAAOyP,QAAQ,CAACnP,UAAhB,KAA+B,WAA1D,EAAuE;EACrE8I,IAAAA,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWgF,cAAc,CAACqB,QAAQ,CAACnP,UAAV,CAAzB,CAAhB;EACD;;EAED,SAAO8I,UAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS4G,sBAAT,CAAgChQ,IAAhC,EAAsC+K,KAAtC,EAA6CyC,SAA7C,EAAwDvN,UAAxD,EAAoEZ,MAApE,EAA4E;EAC1E,MAAMqQ,EAAE,GAAG3E,KAAK,GAAGwD,kBAAH,GAAwBD,mBAAxC;EAEA,MAAMvC,KAAK,GAAG,EAAd;;EAEA,MAAI/L,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAI,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IAAwCuN,SAAS,KAAK,KAA1D,EACEkC,EAAE,CAAC3D,KAAD,EAAQ9L,UAAU,MAAlB,EAAuBZ,MAAvB,CAAF;EAEF,QAAI,OAAOY,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IAAyCmN,SAAS,KAAK,IAA3D,EACEkC,EAAE,CAAC3D,KAAD,EAAQ9L,UAAU,CAACI,GAAnB,EAAwBhB,MAAxB,CAAF,CANuB;;EASzB,QAAI,CAACmO,SAAD,IAAcvN,UAAU,CAACoK,iBAAX,GAA+B,CAAjD,EACE0B,KAAK,CAAC4D,MAAN,CAAa5D,KAAK,CAAC6D,WAAN,CAAkB3P,UAAU,CAACoH,GAA7B,CAAb,EAAgD,CAAhD;EACH;;EAED,MAAIrH,IAAI,KAAK,UAAb,EAAyB;EACvB,QAAI,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAArC,EACEoP,EAAE,CAAC3D,KAAD,EAAQ9L,UAAU,CAACK,UAAnB,EAA+BjB,MAA/B,CAAF;EACH;;EAED,SAAO0M,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASkE,kBAAT,CAA4BjQ,IAA5B,EAAkC+K,KAAlC,EAAyCyC,SAAzC,EAAoDvN,UAApD,EAAgEZ,MAAhE,EAAwEwO,QAAxE,EAAkF;EAChF,MAAM6B,EAAE,GAAG3E,KAAK,GAAG2D,kBAAH,GAAwBD,mBAAxC;;EAEA,MAAIzO,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAI,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IAAwCuN,SAAS,KAAK,KAA1D,EACEkC,EAAE,CAACzP,UAAU,MAAX,EAAgBZ,MAAhB,EAAwBwO,QAAxB,CAAF;EAEF,QAAI5N,UAAU,CAACoH,GAAX,KAAmBhI,MAAvB,EACE,IAAI,OAAOY,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IAAyCmN,SAAS,KAAK,IAA3D,EACEkC,EAAE,CAACzP,UAAU,CAACI,GAAZ,EAAiBhB,MAAjB,EAAyBwO,QAAzB,CAAF;EACL;;EAED,MAAI7N,IAAI,KAAK,UAAb,EAAyB;EACvB,QAAI,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAArC,EACEoP,EAAE,CAACzP,UAAU,CAACK,UAAZ,EAAwBjB,MAAxB,EAAgCwO,QAAhC,CAAF;EACH;EACF;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASqC,uBAAT,CAAiClQ,IAAjC,EAAuC+K,KAAvC,EAA8CyC,SAA9C,EAAyDvN,UAAzD,EAAqEZ,MAArE,EAA6EwO,QAA7E,EAAuF;EACrF,MAAM6B,EAAE,GAAG3E,KAAK,GAAG6D,uBAAH,GAA6BD,wBAA7C;EAEA,MAAIV,WAAW,GAAG,KAAlB;;EAEA,MAAIjO,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAI,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IAAwCuN,SAAS,KAAK,KAA1D,EAAiE;EAC/DS,MAAAA,WAAW,GAAGyB,EAAE,CAACzP,UAAU,MAAX,EAAgBZ,MAAhB,EAAwBwO,QAAxB,CAAhB;EAEA,UAAII,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,QAAIhO,UAAU,CAACoH,GAAX,KAAmBhI,MAAvB,EACE,IAAI,OAAOY,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IAAyCmN,SAAS,KAAK,IAA3D,EAAiE;EAC/DS,MAAAA,WAAW,GAAGyB,EAAE,CAACzP,UAAU,CAACI,GAAZ,EAAiBhB,MAAjB,EAAyBwO,QAAzB,EAAmC,CAACL,SAAD,GAAavN,UAAU,CAACoH,GAAxB,GAA8B,IAAjE,CAAhB;EAEA,UAAI4G,WAAJ,EACE,OAAO,IAAP;EACH;EACJ;;EAED,MAAIjO,IAAI,KAAK,UAAb,EAAyB;EACvB,QAAI,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAArC,EAAkD;EAChD2N,MAAAA,WAAW,GAAGyB,EAAE,CAACzP,UAAU,CAACK,UAAZ,EAAwBjB,MAAxB,EAAgCwO,QAAhC,CAAhB;EAEA,UAAII,WAAJ,EACE,OAAO,IAAP;EACH;EACF;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASkC,yBAAT,CAAmCnQ,IAAnC,EAAyCwN,SAAzC,EAAoDvN,UAApD,EAAgEZ,MAAhE,EAAwE;EACtE,MAAI+J,UAAQ,GAAGN,QAAQ,CAACQ,KAAT,EAAf;;EAEA,MAAItJ,IAAI,KAAK,YAAb,EAA2B;EAEzB,QACE,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IACAuN,SAAS,KAAK,KADd,IAEAnO,MAAM,IAAIY,UAAU,MAHtB,EAKEmJ,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWyF,oBAAoB,CAAC5O,UAAU,MAAX,EAAgBZ,MAAhB,CAA/B,CAAhB;EAEF,QACE,OAAOY,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IACAmN,SAAS,KAAK,IADd,IAEAnO,MAAM,IAAIY,UAAU,CAACI,GAHvB,EAKE+I,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWyF,oBAAoB,CAAC5O,UAAU,CAACI,GAAZ,EAAiBhB,MAAjB,CAA/B,CAAhB;EACH;;EAED,MAAIW,IAAI,KAAK,UAAb,EAAyB;EACvB,QACE,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAAjC,IACAjB,MAAM,IAAIY,UAAU,CAACK,UAFvB,EAIE8I,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWyF,oBAAoB,CAAC5O,UAAU,CAACK,UAAZ,EAAwBjB,MAAxB,CAA/B,CAAhB;EACH;;EAED,SAAO+J,UAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASgH,sBAAT,CAAgCnE,KAAhC,EAAuCoE,WAAvC,EAAoD;EAClD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACEvB,EAAAA,KAAK,CAAC7J,SAAN,CAAgBpB,IAAhB,IAAwB,UAASjB,MAAT,EAAiBV,MAAjB,EAAyB;EAE/C;EACA,QAAIW,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO,EAAP;EAEF,QAAI,CAACV,SAAS,CAACG,MAAf,EACE,OAAOsP,eAAe,CAAC,IAAD,EAAO/O,IAAP,CAAtB;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAM0P,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,OAAO0P,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgC/I,IAAhC,oCAA6DjB,MAA7D,2BAAN,CANwB;;EAS1B,aAAOyP,sBAAsB,CAC3B,KAAKzE,KADsB,EAE3B/K,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IAFJ,EAG3BwN,SAH2B,EAI3BiC,QAJ2B,CAA7B;EAMD;;EAED,QAAInQ,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAMY,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgC/I,IAAhC,qCAA8DjB,MAA9D,kCAAN;EAEF,UAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,iBAAgC/I,IAAhC,qCAA8D3B,MAA9D,kCAAN,CAVwB;;EAa1B,aAAO2Q,sBAAsB,CAAChQ,IAAD,EAAO,KAAK+K,KAAZ,EAAmByC,SAAnB,EAA8BvN,UAA9B,EAA0CZ,MAA1C,CAA7B;EACD;;EAED,UAAM,IAAIwK,0BAAJ,iBAAwC7I,IAAxC,+DAAiG1B,SAAS,CAACG,MAA3G,QAAN;EACD,GA3CD;EA4CD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS8Q,iBAAT,CAA2BtE,KAA3B,EAAkCoE,WAAlC,EAA+C;EAC7C,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAMgD,WAAW,GAAG,YAAYxP,IAAI,CAAC,CAAD,CAAJ,CAAQyP,WAAR,EAAZ,GAAoCzP,IAAI,CAACuH,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAxD;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBoO,WAAhB,IAA+B,UAASzQ,MAAT,EAAiBV,MAAjB,EAAyBwO,QAAzB,EAAmC;EAEhE;EACA,QAAI7N,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BoO,MAAAA,QAAQ,GAAG9N,MAAX;EACA,aAAOqP,WAAW,CAAC,IAAD,EAAOpP,IAAP,EAAa6N,QAAb,CAAlB;EACD;;EAED,QAAIvO,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACA8N,MAAAA,QAAQ,GAAGxO,MAAX;;EAEA,UAAMoQ,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,OAAO0P,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgCyG,WAAhC,oCAAoEzQ,MAApE,2BAAN,CAPwB;EAU1B;;EACA,aAAO8P,kBAAkB,CACvB,KAAK9E,KADkB,EAEvB/K,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IAFR,EAGvBwN,SAHuB,EAIvBiC,QAJuB,EAKvB5B,QALuB,CAAzB;EAOD;;EAED,QAAIvO,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAMY,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgCyG,WAAhC,qCAAqEzQ,MAArE,kCAAN;EAEF,UAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,iBAAgCyG,WAAhC,qCAAqEnR,MAArE,kCAAN,CAVwB;;EAa1B,aAAO4Q,kBAAkB,CAACjQ,IAAD,EAAO,KAAK+K,KAAZ,EAAmByC,SAAnB,EAA8BvN,UAA9B,EAA0CZ,MAA1C,EAAkDwO,QAAlD,CAAzB;EACD;;EAED,UAAM,IAAIhE,0BAAJ,iBAAwC2G,WAAxC,+DAAwGlR,SAAS,CAACG,MAAlH,QAAN;EACD,GAhDD;EAiDD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASiR,sBAAT,CAAgCzE,KAAhC,EAAuCoE,WAAvC,EAAoD;EAClD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAMmD,gBAAgB,GAAG,YAAY3P,IAAI,CAAC,CAAD,CAAJ,CAAQyP,WAAR,EAAZ,GAAoCzP,IAAI,CAACuH,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAApC,GAAwD,OAAjF;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBuO,gBAAhB,IAAoC,UAAS5Q,MAAT,EAAiBV,MAAjB,EAAyBwO,QAAzB,EAAmC;EAErE;EACA,QAAI7N,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO,KAAP;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BoO,MAAAA,QAAQ,GAAG9N,MAAX;EACA,aAAOuP,gBAAgB,CAAC,IAAD,EAAOtP,IAAP,EAAa6N,QAAb,CAAvB;EACD;;EAED,QAAIvO,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACA8N,MAAAA,QAAQ,GAAGxO,MAAX;;EAEA,UAAMoQ,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,OAAO0P,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgC4G,gBAAhC,oCAAyE5Q,MAAzE,2BAAN,CAPwB;EAU1B;;EACA,aAAO+P,uBAAuB,CAC5B,KAAK/E,KADuB,EAE5B/K,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IAFH,EAG5BwN,SAH4B,EAI5BiC,QAJ4B,EAK5B5B,QAL4B,CAA9B;EAOD;;EAED,QAAIvO,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAMY,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgC4G,gBAAhC,qCAA0E5Q,MAA1E,kCAAN;EAEF,UAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,iBAAgC4G,gBAAhC,qCAA0EtR,MAA1E,kCAAN,CAVwB;;EAa1B,aAAO6Q,uBAAuB,CAAClQ,IAAD,EAAO,KAAK+K,KAAZ,EAAmByC,SAAnB,EAA8BvN,UAA9B,EAA0CZ,MAA1C,EAAkDwO,QAAlD,CAA9B;EACD;;EAED,UAAM,IAAIhE,0BAAJ,iBAAwC8G,gBAAxC,+DAA6GrR,SAAS,CAACG,MAAvH,QAAN;EACD,GAhDD;EAiDD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACO,SAASmR,yBAAT,CAAmC3E,KAAnC,EAA0CoE,WAA1C,EAAuD;EAC5D,MACQQ,YADR,GAIIR,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAMxM,IAAI,GAAG6P,YAAY,CAACtI,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,IAA4B,SAAzC;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBpB,IAAhB,IAAwB,UAASjB,MAAT,EAAiBV,MAAjB,EAAyB;EAE/C;EACA,QAAIW,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO8I,QAAQ,CAACQ,KAAT,EAAP;EAEF,QAAI,CAAChK,SAAS,CAACG,MAAf,EACE,OAAO8P,kBAAkB,CAAC,IAAD,EAAOvP,IAAP,CAAzB;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAME,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgC/I,IAAhC,oCAA6DjB,MAA7D,2BAAN,CANwB;;EAS1B,aAAOgQ,yBAAyB,CAAC/P,IAAD,EAAOwN,SAAP,EAAkBvN,UAAlB,CAAhC;EACD;;EAED,QAAIX,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,UAAMY,WAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,UAAI,CAACE,WAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgC/I,IAAhC,qCAA8DjB,MAA9D,kCAAN;EAEF,UAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,iBAAgC/I,IAAhC,qCAA8D3B,MAA9D,kCAAN,CAVwB;;EAa1B,aAAO8Q,yBAAyB,CAACnQ,IAAD,EAAOwN,SAAP,EAAkBvN,WAAlB,EAA8BZ,MAA9B,CAAhC;EACD;;EAED,UAAM,IAAIwK,0BAAJ,iBAAwC7I,IAAxC,+DAAiG1B,SAAS,CAACG,MAA3G,QAAN;EACD,GAtCD;EAuCD;EAED;EACA;EACA;EACA;EACA;;EACO,SAASqR,0BAAT,CAAoC7D,KAApC,EAA2C;EAChDM,EAAAA,eAAe,CAAC5B,OAAhB,CAAwB,UAAA0E,WAAW,EAAI;EACrCD,IAAAA,sBAAsB,CAACnD,KAAD,EAAQoD,WAAR,CAAtB;EACAE,IAAAA,iBAAiB,CAACtD,KAAD,EAAQoD,WAAR,CAAjB;EACAK,IAAAA,sBAAsB,CAACzD,KAAD,EAAQoD,WAAR,CAAtB;EACAO,IAAAA,yBAAyB,CAAC3D,KAAD,EAAQoD,WAAR,CAAzB;EACD,GALD;EAMD;;EC/qCD;EACA;EACA;EACA;EACA;EACA;EACA;EAUA;EACA;EACA;;EACA,IAAMU,mBAAmB,GAAG,CAC1B;EACE/P,EAAAA,IAAI,EAAE,WADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CAD0B,EAK1B;EACEgB,EAAAA,IAAI,EAAE,aADR;EAEEhB,EAAAA,IAAI,EAAE,UAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CAL0B,EAU1B;EACExM,EAAAA,IAAI,EAAE,cADR;EAEEhB,EAAAA,IAAI,EAAE,UAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CAV0B,EAe1B;EACExM,EAAAA,IAAI,EAAE,kBADR;EAEEhB,EAAAA,IAAI,EAAE,OAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CAf0B,EAoB1B;EACExM,EAAAA,IAAI,EAAE,mBADR;EAEEhB,EAAAA,IAAI,EAAE,OAFR;EAGEwN,EAAAA,SAAS,EAAE;EAHb,CApB0B,EAyB1B;EACExM,EAAAA,IAAI,EAAE,mBADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CAzB0B,EA6B1B;EACEgB,EAAAA,IAAI,EAAE,qBADR;EAEEhB,EAAAA,IAAI,EAAE;EAFR,CA7B0B,CAA5B;EAmCA;EACA;EACA;EACA;EACA;EACA;;EACA,SAASgR,KAAT,CAAeC,SAAf,EAA0BvD,MAA1B,EAAkC;EAChC,MAAI,OAAOA,MAAP,KAAkB,WAAtB,EACE;;EAEF,OAAK,IAAM5B,QAAX,IAAuB4B,MAAvB;EACEuD,IAAAA,SAAS,CAAC5F,GAAV,CAAcS,QAAd;EADF;EAED;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASoF,0BAAT,CAAoClR,IAApC,EAA0CwN,SAA1C,EAAqDiC,QAArD,EAA+D;EAE7D;EACA,MAAIzP,IAAI,KAAK,OAAb,EAAsB;EACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAOJ,MAAM,CAACwH,IAAP,CAAYqI,QAAQ,CAACnP,UAArB,CAAP;EAEF,QAAI,OAAOkN,SAAP,KAAqB,QAAzB,EACE,OAAO5N,MAAM,CAACwH,IAAP,CAAYqI,QAAQ,CAACjC,SAAD,CAApB,CAAP;EACH,GAT4D;;;EAY7D,MAAMyD,SAAS,GAAG,IAAI7F,GAAJ,EAAlB;;EAEA,MAAIpL,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAIwN,SAAS,KAAK,KAAlB,EAAyB;EACvBwD,MAAAA,KAAK,CAACC,SAAD,EAAYxB,QAAQ,MAApB,CAAL;EACD;;EACD,QAAIjC,SAAS,KAAK,IAAlB,EAAwB;EACtBwD,MAAAA,KAAK,CAACC,SAAD,EAAYxB,QAAQ,CAACpP,GAArB,CAAL;EACD;EACF;;EAED,MAAIL,IAAI,KAAK,UAAb,EAAyB;EACvBgR,IAAAA,KAAK,CAACC,SAAD,EAAYxB,QAAQ,CAACnP,UAArB,CAAL;EACD;;EAED,SAAOkJ,IAAI,CAACyH,SAAS,CAAC9C,MAAV,EAAD,EAAqB8C,SAAS,CAACzF,IAA/B,CAAX;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS2F,eAAT,CAAyB1B,QAAzB,EAAmC/B,MAAnC,EAA2CG,QAA3C,EAAqD;EACnD,OAAK,IAAMnO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAI7C,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAArB;EAEA,QAAImL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA4N,IAAAA,QAAQ,CACNuD,YAAY,CAAC/J,GADP,EAEN+J,YAAY,CAAC3P,UAFP,CAAR;EAID;EACF;;EAED,SAAS4P,mBAAT,CAA6BC,OAA7B,EAAsC7B,QAAtC,EAAgD/B,MAAhD,EAAwDG,QAAxD,EAAkE;EAChE,OAAK,IAAMnO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAI7C,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAArB;EAEA,QAAImL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA,QAAIqR,OAAO,CAAChB,GAAR,CAAYc,YAAY,CAAC/J,GAAzB,CAAJ,EACE;EAEFiK,IAAAA,OAAO,CAACjG,GAAR,CAAY+F,YAAY,CAAC/J,GAAzB;EAEAwG,IAAAA,QAAQ,CACNuD,YAAY,CAAC/J,GADP,EAEN+J,YAAY,CAAC3P,UAFP,CAAR;EAID;EACF;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS8P,oBAAT,CAA8B9B,QAA9B,EAAwC/B,MAAxC,EAAgDG,QAAhD,EAA0D;EACxD,OAAK,IAAMnO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAI7C,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAArB;EAEA,QAAImL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA,QAAMgO,WAAW,GAAGJ,QAAQ,CAC1BuD,YAAY,CAAC/J,GADa,EAE1B+J,YAAY,CAAC3P,UAFa,CAA5B;EAKA,QAAIwM,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;;EAED,SAASuD,wBAAT,CAAkCF,OAAlC,EAA2C7B,QAA3C,EAAqD/B,MAArD,EAA6DG,QAA7D,EAAuE;EACrE,OAAK,IAAMnO,CAAX,IAAgBgO,MAAhB,EAAwB;EACtB,QAAI7C,QAAQ,GAAG6C,MAAM,CAAChO,CAAD,CAArB;EAEA,QAAImL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA,QAAIqR,OAAO,CAAChB,GAAR,CAAYc,YAAY,CAAC/J,GAAzB,CAAJ,EACE;EAEFiK,IAAAA,OAAO,CAACjG,GAAR,CAAY+F,YAAY,CAAC/J,GAAzB;EAEA,QAAM4G,WAAW,GAAGJ,QAAQ,CAC1BuD,YAAY,CAAC/J,GADa,EAE1B+J,YAAY,CAAC3P,UAFa,CAA5B;EAKA,QAAIwM,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;;EAED,SAASwD,sBAAT,CAAgCzR,IAAhC,EAAsCwN,SAAtC,EAAiDiC,QAAjD,EAA2D5B,QAA3D,EAAqE;EAEnE;EACA,MAAI7N,IAAI,KAAK,OAAb,EAAsB;EACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAOmR,eAAe,CAAC1B,QAAD,EAAWA,QAAQ,CAACnP,UAApB,EAAgCuN,QAAhC,CAAtB;EAEF,QAAI,OAAOL,SAAP,KAAqB,QAAzB,EACE,OAAO2D,eAAe,CAAC1B,QAAD,EAAWA,QAAQ,CAACjC,SAAD,CAAnB,EAAgCK,QAAhC,CAAtB;EACH,GATkE;;;EAYnE,MAAMyD,OAAO,GAAG,IAAIlG,GAAJ,EAAhB;;EAEA,MAAIpL,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAIwN,SAAS,KAAK,KAAlB,EAAyB;EACvB6D,MAAAA,mBAAmB,CAACC,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,MAA5B,EAAiC5B,QAAjC,CAAnB;EACD;;EACD,QAAIL,SAAS,KAAK,IAAlB,EAAwB;EACtB6D,MAAAA,mBAAmB,CAACC,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACpP,GAA7B,EAAkCwN,QAAlC,CAAnB;EACD;EACF;;EAED,MAAI7N,IAAI,KAAK,UAAb,EAAyB;EACvBqR,IAAAA,mBAAmB,CAACC,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACnP,UAA7B,EAAyCuN,QAAzC,CAAnB;EACD;EACF;;EAED,SAAS6D,2BAAT,CAAqC1R,IAArC,EAA2CwN,SAA3C,EAAsDiC,QAAtD,EAAgE5B,QAAhE,EAA0E;EAExE;EACA,MAAI7N,IAAI,KAAK,OAAb,EAAsB;EACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAOuR,oBAAoB,CAAC9B,QAAD,EAAWA,QAAQ,CAACnP,UAApB,EAAgCuN,QAAhC,CAA3B;EAEF,QAAI,OAAOL,SAAP,KAAqB,QAAzB,EACE,OAAO+D,oBAAoB,CAAC9B,QAAD,EAAWA,QAAQ,CAACjC,SAAD,CAAnB,EAAgCK,QAAhC,CAA3B;EACH,GATuE;;;EAYxE,MAAMyD,OAAO,GAAG,IAAIlG,GAAJ,EAAhB;EAEA,MAAI6C,WAAW,GAAG,KAAlB;;EAEA,MAAIjO,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAIwN,SAAS,KAAK,KAAlB,EAAyB;EACvBS,MAAAA,WAAW,GAAGuD,wBAAwB,CAACF,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,MAA5B,EAAiC5B,QAAjC,CAAtC;EAEA,UAAII,WAAJ,EACE,OAAO,IAAP;EACH;;EACD,QAAIT,SAAS,KAAK,IAAlB,EAAwB;EACtBS,MAAAA,WAAW,GAAGuD,wBAAwB,CAACF,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACpP,GAA7B,EAAkCwN,QAAlC,CAAtC;EAEA,UAAII,WAAJ,EACE,OAAO,IAAP;EACH;EACF;;EAED,MAAIjO,IAAI,KAAK,UAAb,EAAyB;EACvBiO,IAAAA,WAAW,GAAGuD,wBAAwB,CAACF,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACnP,UAA7B,EAAyCuN,QAAzC,CAAtC;EAEA,QAAII,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS0D,oBAAT,CAA8BlC,QAA9B,EAAwC/B,MAAxC,EAAgD;EAC9C,MAAMtG,IAAI,GAAGxH,MAAM,CAACwH,IAAP,CAAYsG,MAAZ,CAAb;EAAA,MACMlO,CAAC,GAAG4H,IAAI,CAAC3H,MADf;EAGA,MAAIF,CAAC,GAAG,CAAR;EAEA,SAAO,IAAIuJ,QAAJ,CAAa,YAAW;EAC7B,QAAIvJ,CAAC,IAAIC,CAAT,EACE,OAAO;EAACwJ,MAAAA,IAAI,EAAE;EAAP,KAAP;EAEF,QAAI6B,QAAQ,GAAG6C,MAAM,CAACtG,IAAI,CAAC7H,CAAC,EAAF,CAAL,CAArB;EAEA,QAAIsL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA,WAAO;EACL+I,MAAAA,IAAI,EAAE,KADD;EAELxI,MAAAA,KAAK,EAAE,CAAC4Q,YAAY,CAAC/J,GAAd,EAAmB+J,YAAY,CAAC3P,UAAhC;EAFF,KAAP;EAID,GAlBM,CAAP;EAmBD;;EAED,SAASmQ,2BAAT,CAAqCN,OAArC,EAA8C7B,QAA9C,EAAwD/B,MAAxD,EAAgE;EAC9D,MAAMtG,IAAI,GAAGxH,MAAM,CAACwH,IAAP,CAAYsG,MAAZ,CAAb;EAAA,MACMlO,CAAC,GAAG4H,IAAI,CAAC3H,MADf;EAGA,MAAIF,CAAC,GAAG,CAAR;EAEA,SAAO,IAAIuJ,QAAJ,CAAa,SAASC,IAAT,GAAgB;EAClC,QAAIxJ,CAAC,IAAIC,CAAT,EACE,OAAO;EAACwJ,MAAAA,IAAI,EAAE;EAAP,KAAP;EAEF,QAAI6B,QAAQ,GAAG6C,MAAM,CAACtG,IAAI,CAAC7H,CAAC,EAAF,CAAL,CAArB;EAEA,QAAIsL,QAAQ,YAAYO,GAAxB,EACEP,QAAQ,GAAGA,QAAQ,CAACsD,MAAT,GAAkBpF,IAAlB,GAAyBvI,KAApC;EAEF,QAAMP,UAAU,GAAG4K,QAAQ,CAAC9K,MAA5B;EAAA,QACM+K,UAAU,GAAGD,QAAQ,CAACxL,MAD5B;EAGA,QAAM+R,YAAY,GAAGnR,UAAU,KAAKwP,QAAf,GAA0B3E,UAA1B,GAAuC7K,UAA5D;EAEA,QAAIqR,OAAO,CAAChB,GAAR,CAAYc,YAAY,CAAC/J,GAAzB,CAAJ,EACE,OAAO0B,IAAI,EAAX;EAEFuI,IAAAA,OAAO,CAACjG,GAAR,CAAY+F,YAAY,CAAC/J,GAAzB;EAEA,WAAO;EACL2B,MAAAA,IAAI,EAAE,KADD;EAELxI,MAAAA,KAAK,EAAE,CAAC4Q,YAAY,CAAC/J,GAAd,EAAmB+J,YAAY,CAAC3P,UAAhC;EAFF,KAAP;EAID,GAvBM,CAAP;EAwBD;;EAED,SAASoQ,sBAAT,CAAgC7R,IAAhC,EAAsCwN,SAAtC,EAAiDiC,QAAjD,EAA2D;EAEzD;EACA,MAAIzP,IAAI,KAAK,OAAb,EAAsB;EACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAO2R,oBAAoB,CAAClC,QAAD,EAAWA,QAAQ,CAACnP,UAApB,CAA3B;EAEF,QAAI,OAAOkN,SAAP,KAAqB,QAAzB,EACE,OAAOmE,oBAAoB,CAAClC,QAAD,EAAWA,QAAQ,CAACjC,SAAD,CAAnB,CAA3B;EACH;;EAED,MAAIpE,UAAQ,GAAGN,QAAQ,CAACQ,KAAT,EAAf,CAXyD;;EAczD,MAAMgI,OAAO,GAAG,IAAIlG,GAAJ,EAAhB;;EAEA,MAAIpL,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAIwN,SAAS,KAAK,KAAlB,EAAyB;EACvBpE,MAAAA,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWwI,2BAA2B,CAACN,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,MAA5B,CAAtC,CAAhB;EACD;;EACD,QAAIjC,SAAS,KAAK,IAAlB,EAAwB;EACtBpE,MAAAA,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWwI,2BAA2B,CAACN,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACpP,GAA7B,CAAtC,CAAhB;EACD;EACF;;EAED,MAAIL,IAAI,KAAK,UAAb,EAAyB;EACvBoJ,IAAAA,UAAQ,GAAG+D,KAAK,CAAC/D,UAAD,EAAWwI,2BAA2B,CAACN,OAAD,EAAU7B,QAAV,EAAoBA,QAAQ,CAACnP,UAA7B,CAAtC,CAAhB;EACD;;EAED,SAAO8I,UAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAAS0I,eAAT,CAAyBhS,KAAzB,EAAgCE,IAAhC,EAAsCwN,SAAtC,EAAiD3B,IAAjD,EAAuDC,QAAvD,EAAiE;EAE/D,MAAM2D,QAAQ,GAAG3P,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiB0L,IAAjB,CAAjB;;EAEA,MAAI7L,IAAI,KAAK,YAAb,EAA2B;EAEzB,QAAIwN,SAAS,KAAK,KAAd,IAAuB,OAAOiC,QAAQ,MAAf,KAAuB,WAAlD,EAA+D;EAC7D,WAAK,IAAM/P,CAAX,IAAgB+P,QAAQ,MAAxB;EACE,YAAI/P,CAAC,KAAKoM,QAAV,EACE,OAAO,IAAP;EAFJ;EAGD;;EACD,QAAI0B,SAAS,KAAK,IAAd,IAAsB,OAAOiC,QAAQ,CAACpP,GAAhB,KAAwB,WAAlD,EAA+D;EAC7D,WAAK,IAAMX,EAAX,IAAgB+P,QAAQ,CAACpP,GAAzB;EACE,YAAIX,EAAC,KAAKoM,QAAV,EACE,OAAO,IAAP;EAFJ;EAGD;EACF;;EAED,MAAI9L,IAAI,KAAK,UAAT,IAAuB,OAAOyP,QAAQ,CAACnP,UAAhB,KAA+B,WAA1D,EAAuE;EACrE,SAAK,IAAMZ,GAAX,IAAgB+P,QAAQ,CAACnP,UAAzB;EACI,UAAIZ,GAAC,KAAKoM,QAAV,EACE,OAAO,IAAP;EAFN;EAGD;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASiG,0BAAT,CAAoC9F,KAApC,EAA2CoE,WAA3C,EAAwD;EACtD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACEvB,EAAAA,KAAK,CAAC7J,SAAN,CAAgBpB,IAAhB,IAAwB,UAAS6K,IAAT,EAAe;EAErC;EACA,QAAI7L,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO,EAAP;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,UAAMuS,KAAK,GAAG,KAAK1S,SAAS,CAAC,CAAD,CAA5B;EAAA,UACM2S,KAAK,GAAG,KAAK3S,SAAS,CAAC,CAAD,CAD5B;EAGA,UAAI,CAAC,KAAKY,MAAL,CAAYoQ,GAAZ,CAAgB0B,KAAhB,CAAL,EACE,MAAM,IAAIjI,kBAAJ,iBAAgC/I,IAAhC,oCAA6DgR,KAA7D,2BAAN;EAEF,UAAI,CAAC,KAAK9R,MAAL,CAAYoQ,GAAZ,CAAgB2B,KAAhB,CAAL,EACE,MAAM,IAAIlI,kBAAJ,iBAAgC/I,IAAhC,oCAA6DiR,KAA7D,2BAAN,CARwB;;EAW1B,aAAOH,eAAe,CACpB,IADoB,EAEpB9R,IAFoB,EAGpBwN,SAHoB,EAIpBwE,KAJoB,EAKpBC,KALoB,CAAtB;EAOD,KAlBD,MAmBK,IAAI3S,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC/BoM,MAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,UAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,UAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgC/I,IAAhC,oCAA6D6K,IAA7D,2BAAN,CAN6B;;EAS/B,UAAMoF,SAAS,GAAGC,0BAA0B,CAC1ClR,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADW,EAE1CwN,SAF0C,EAG1CiC,QAH0C,CAA5C;EAMA,aAAOwB,SAAP;EACD;;EAED,UAAM,IAAIpH,0BAAJ,iBAAwC7I,IAAxC,qEAAuG1B,SAAS,CAACG,MAAjH,QAAN;EACD,GA5CD;EA6CD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASyS,qBAAT,CAA+BjG,KAA/B,EAAsCoE,WAAtC,EAAmD;EACjD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAMgD,WAAW,GAAG,YAAYxP,IAAI,CAAC,CAAD,CAAJ,CAAQyP,WAAR,EAAZ,GAAoCzP,IAAI,CAACuH,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAxD;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBoO,WAAhB,IAA+B,UAAS3E,IAAT,EAAegC,QAAf,EAAyB;EAEtD;EACA,QAAI7N,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE;EAEF6L,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgCyG,WAAhC,oCAAoE3E,IAApE,2BAAN,CAXoD;;EActD4F,IAAAA,sBAAsB,CACpBzR,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADX,EAEpBwN,SAFoB,EAGpBiC,QAHoB,EAIpB5B,QAJoB,CAAtB;EAMD,GApBD;EAqBD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASsE,0BAAT,CAAoClG,KAApC,EAA2CoE,WAA3C,EAAwD;EACtD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAMmD,gBAAgB,GAAG,YAAY3P,IAAI,CAAC,CAAD,CAAJ,CAAQyP,WAAR,EAAZ,GAAoCzP,IAAI,CAACuH,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAApC,GAAwD,OAAjF;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBuO,gBAAhB,IAAoC,UAAS9E,IAAT,EAAegC,QAAf,EAAyB;EAE3D;EACA,QAAI7N,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE;EAEF6L,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgC4G,gBAAhC,oCAAyE9E,IAAzE,2BAAN,CAXyD;;EAc3D,WAAO6F,2BAA2B,CAChC1R,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADC,EAEhCwN,SAFgC,EAGhCiC,QAHgC,EAIhC5B,QAJgC,CAAlC;EAMD,GApBD;EAqBD;EAED;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASuE,6BAAT,CAAuCnG,KAAvC,EAA8CoE,WAA9C,EAA2D;EACzD,MACErP,IADF,GAIIqP,WAJJ,CACErP,IADF;EAAA,MAEEhB,IAFF,GAIIqQ,WAJJ,CAEErQ,IAFF;EAAA,MAGEwN,SAHF,GAII6C,WAJJ,CAGE7C,SAHF;EAMA,MAAM6E,YAAY,GAAGrR,IAAI,CAACuH,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,IAAoB,SAAzC;EAEA;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;EACE0D,EAAAA,KAAK,CAAC7J,SAAN,CAAgBiQ,YAAhB,IAAgC,UAASxG,IAAT,EAAe;EAE7C;EACA,QAAI7L,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO8I,QAAQ,CAACQ,KAAT,EAAP;EAEFuC,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI1F,kBAAJ,iBAAgCsI,YAAhC,oCAAqExG,IAArE,2BAAN,CAX2C;;EAc7C,WAAOgG,sBAAsB,CAC3B7R,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADJ,EAE3BwN,SAF2B,EAG3BiC,QAH2B,CAA7B;EAKD,GAnBD;EAoBD;EAED;EACA;EACA;EACA;EACA;;;EACO,SAAS6C,8BAAT,CAAwCrF,KAAxC,EAA+C;EACpD8D,EAAAA,mBAAmB,CAACpF,OAApB,CAA4B,UAAA0E,WAAW,EAAI;EACzC0B,IAAAA,0BAA0B,CAAC9E,KAAD,EAAQoD,WAAR,CAA1B;EACA6B,IAAAA,qBAAqB,CAACjF,KAAD,EAAQoD,WAAR,CAArB;EACA8B,IAAAA,0BAA0B,CAAClF,KAAD,EAAQoD,WAAR,CAA1B;EACA+B,IAAAA,6BAA6B,CAACnF,KAAD,EAAQoD,WAAR,CAA7B;EACD,GALD;EAMD;;EC/oBD;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASkC,sBAAT,CAAgCC,SAAhC,EAA2C1S,KAA3C,EAAkD+N,QAAlD,EAA4D;EACjE,MAAMzE,QAAQ,GAAGtJ,KAAK,CAACI,MAAN,CAAaiO,MAAb,EAAjB;;EAEA,MAAMnO,IAAI,GAAGF,KAAK,CAACE,IAAnB;EAEA,MAAIiJ,IAAJ,EAAUhJ,UAAV,EAAsB6L,QAAtB,EAAgCZ,GAAhC,EAAqCL,QAArC,EAA+CC,UAA/C,EAA2DmD,WAA3D;;EAEA,SAAQhF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnD/I,IAAAA,UAAU,GAAGgJ,IAAI,CAACzI,KAAlB;;EAEA,QAAIR,IAAI,KAAK,YAAb,EAA2B;EACzBkL,MAAAA,GAAG,GAAGjL,UAAU,CAACI,GAAjB;;EAEA,WAAKyL,QAAL,IAAiBZ,GAAjB,EAAsB;EACpBL,QAAAA,QAAQ,GAAGK,GAAG,CAACY,QAAD,CAAd;EACAhB,QAAAA,UAAU,GAAGD,QAAQ,CAACxL,MAAtB;EAEA4O,QAAAA,WAAW,GAAGJ,QAAQ,CACpB5N,UAAU,CAACoH,GADS,EAEpByD,UAAU,CAACzD,GAFS,EAGpBpH,UAAU,CAACwB,UAHS,EAIpBqJ,UAAU,CAACrJ,UAJS,EAKpBoJ,QAAQ,CAACxD,GALW,EAMpBwD,QAAQ,CAACpJ,UANW,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,YAAI6H,SAAS,IAAIvE,WAAjB,EACE,OAAO,IAAP;EACH;EACF;;EAED,QAAIjO,IAAI,KAAK,UAAb,EAAyB;EACvBkL,MAAAA,GAAG,GAAGjL,UAAU,CAACK,UAAjB;;EAEA,WAAKwL,QAAL,IAAiBZ,GAAjB,EAAsB;EACpBL,QAAAA,QAAQ,GAAGK,GAAG,CAACY,QAAD,CAAd;EACAhB,QAAAA,UAAU,GAAGD,QAAQ,CAACxL,MAAtB;EAEA,YAAIyL,UAAU,CAACzD,GAAX,KAAmByE,QAAvB,EACEhB,UAAU,GAAGD,QAAQ,CAAC9K,MAAtB;EAEFkO,QAAAA,WAAW,GAAGJ,QAAQ,CACpB5N,UAAU,CAACoH,GADS,EAEpByD,UAAU,CAACzD,GAFS,EAGpBpH,UAAU,CAACwB,UAHS,EAIpBqJ,UAAU,CAACrJ,UAJS,EAKpBoJ,QAAQ,CAACxD,GALW,EAMpBwD,QAAQ,CAACpJ,UANW,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,YAAI6H,SAAS,IAAIvE,WAAjB,EACE,OAAO,IAAP;EACH;EACF;EACF;;EAED,SAAO,KAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASwE,qBAAT,CAA+BD,SAA/B,EAA0C1S,KAA1C,EAAiD+N,QAAjD,EAA2D;EAChE,MAAMzE,QAAQ,GAAGtJ,KAAK,CAACI,MAAN,CAAaiO,MAAb,EAAjB;;EAEA,MAAMnO,IAAI,GAAGF,KAAK,CAACE,IAAnB;EAEA,MAAIiJ,IAAJ,EAAUhJ,UAAV,EAAsB6L,QAAtB,EAAgCX,SAAhC,EAA2CuH,aAA3C,EAA0DxH,GAA1D,EAA+DL,QAA/D,EAAyEC,UAAzE,EAAqFmD,WAArF;;EAEA,SAAQhF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnD/I,IAAAA,UAAU,GAAGgJ,IAAI,CAACzI,KAAlB;;EAEA,QAAIR,IAAI,KAAK,YAAb,EAA2B;EACzBkL,MAAAA,GAAG,GAAGjL,UAAU,CAACI,GAAjB;;EAEA,WAAKyL,QAAL,IAAiBZ,GAAjB,EAAsB;EACpBC,QAAAA,SAAS,GAAGD,GAAG,CAACY,QAAD,CAAH,CAAcqC,MAAd,EAAZ;;EAEA,eAAQuE,aAAa,GAAGvH,SAAS,CAACpC,IAAV,EAAhB,EAAkC2J,aAAa,CAAC1J,IAAd,KAAuB,IAAjE,EAAwE;EACtE6B,UAAAA,QAAQ,GAAG6H,aAAa,CAAClS,KAAzB;EACAsK,UAAAA,UAAU,GAAGD,QAAQ,CAACxL,MAAtB;EAEA4O,UAAAA,WAAW,GAAGJ,QAAQ,CACpB5N,UAAU,CAACoH,GADS,EAEpByD,UAAU,CAACzD,GAFS,EAGpBpH,UAAU,CAACwB,UAHS,EAIpBqJ,UAAU,CAACrJ,UAJS,EAKpBoJ,QAAQ,CAACxD,GALW,EAMpBwD,QAAQ,CAACpJ,UANW,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,cAAI6H,SAAS,IAAIvE,WAAjB,EACE,OAAO,IAAP;EACH;EACF;EACF;;EAED,QAAIjO,IAAI,KAAK,UAAb,EAAyB;EACvBkL,MAAAA,GAAG,GAAGjL,UAAU,CAACK,UAAjB;;EAEA,WAAKwL,QAAL,IAAiBZ,GAAjB,EAAsB;EACpBC,QAAAA,SAAS,GAAGD,GAAG,CAACY,QAAD,CAAH,CAAcqC,MAAd,EAAZ;;EAEA,eAAQuE,aAAa,GAAGvH,SAAS,CAACpC,IAAV,EAAhB,EAAkC2J,aAAa,CAAC1J,IAAd,KAAuB,IAAjE,EAAwE;EACtE6B,UAAAA,QAAQ,GAAG6H,aAAa,CAAClS,KAAzB;EACAsK,UAAAA,UAAU,GAAGD,QAAQ,CAACxL,MAAtB;EAEA,cAAIyL,UAAU,CAACzD,GAAX,KAAmByE,QAAvB,EACEhB,UAAU,GAAGD,QAAQ,CAAC9K,MAAtB;EAEFkO,UAAAA,WAAW,GAAGJ,QAAQ,CACpB5N,UAAU,CAACoH,GADS,EAEpByD,UAAU,CAACzD,GAFS,EAGpBpH,UAAU,CAACwB,UAHS,EAIpBqJ,UAAU,CAACrJ,UAJS,EAKpBoJ,QAAQ,CAACxD,GALW,EAMpBwD,QAAQ,CAACpJ,UANW,EAOpBoJ,QAAQ,CAACvK,UAPW,EAQpBuK,QAAQ,CAACF,YARW,CAAtB;EAWA,cAAI6H,SAAS,IAAIvE,WAAjB,EACE,OAAO,IAAP;EACH;EACF;EACF;EACF;;EAED,SAAO,KAAP;EACD;EAEM,SAAS0E,6BAAT,CAAuC7S,KAAvC,EAA8C;EACnD,MAAMsJ,UAAQ,GAAGtJ,KAAK,CAACI,MAAN,CAAaiO,MAAb,EAAjB;;EAEA,MAAMnO,IAAI,GAAGF,KAAK,CAACE,IAAnB;EAEA,MAAIyG,KAAK,GAAG,OAAZ;EAAA,MACIxG,UADJ;EAAA,MAEIgR,SAFJ;EAAA,MAGI/F,GAHJ;EAAA,MAII0H,MAJJ;EAMA,SAAO,IAAI9J,QAAJ,CAAa,SAASC,IAAT,GAAgB;EAClC,QAAIE,IAAJ;;EAEA,QAAIxC,KAAK,KAAK,OAAd,EAAuB;EACrBwC,MAAAA,IAAI,GAAGG,UAAQ,CAACL,IAAT,EAAP;EAEA,UAAIE,IAAI,CAACD,IAAL,KAAc,IAAlB,EACE,OAAOC,IAAP;EAEFhJ,MAAAA,UAAU,GAAGgJ,IAAI,CAACzI,KAAlB;EAEAiG,MAAAA,KAAK,GAAG,UAAR;EACA,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAItC,KAAK,KAAK,UAAd,EAA0B;EACxB,UAAIzG,IAAI,KAAK,YAAb,EAA2B;EACzByG,QAAAA,KAAK,GAAG,YAAR;EACA,eAAOsC,IAAI,EAAX;EACD;;EAEDmC,MAAAA,GAAG,GAAGjL,UAAU,CAACI,GAAjB;EACA4Q,MAAAA,SAAS,GAAGrR,MAAM,CAACwH,IAAP,CAAYnH,UAAU,CAACI,GAAvB,CAAZ;EACAuS,MAAAA,MAAM,GAAG,CAAT;EACAnM,MAAAA,KAAK,GAAG,gBAAR;EAEA,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAItC,KAAK,KAAK,YAAd,EAA4B;EAC1B,UAAIzG,IAAI,KAAK,UAAb,EAAyB;EACvByG,QAAAA,KAAK,GAAG,OAAR;EACA,eAAOsC,IAAI,EAAX;EACD;;EAEDmC,MAAAA,GAAG,GAAGjL,UAAU,CAACK,UAAjB;EACA2Q,MAAAA,SAAS,GAAGrR,MAAM,CAACwH,IAAP,CAAYnH,UAAU,CAACK,UAAvB,CAAZ;EACAsS,MAAAA,MAAM,GAAG,CAAT;EACAnM,MAAAA,KAAK,GAAG,kBAAR;EACD,KAvCiC;;;EA0ClC,QAAImM,MAAM,IAAI3B,SAAS,CAACxR,MAAxB,EAAgC;EAC9B,UAAIgH,KAAK,KAAK,kBAAd,EACEA,KAAK,GAAG,OAAR,CADF,KAGEA,KAAK,GAAG,YAAR;EAEF,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAM+C,QAAQ,GAAGmF,SAAS,CAAC2B,MAAM,EAAP,CAA1B;EACA,QAAM/H,QAAQ,GAAGK,GAAG,CAACY,QAAD,CAApB;EACA,QAAIhB,UAAU,GAAGD,QAAQ,CAACxL,MAA1B;EAEA,QAAIoH,KAAK,KAAK,kBAAV,IAAgCqE,UAAU,CAACzD,GAAX,KAAmBpH,UAAU,CAACoH,GAAlE,EACEyD,UAAU,GAAGD,QAAQ,CAAC9K,MAAtB;EAEF,WAAO;EACLiJ,MAAAA,IAAI,EAAE,KADD;EAELxI,MAAAA,KAAK,EAAE,CACLP,UAAU,CAACoH,GADN,EAELyD,UAAU,CAACzD,GAFN,EAGLpH,UAAU,CAACwB,UAHN,EAILqJ,UAAU,CAACrJ,UAJN,EAKLoJ,QAAQ,CAACxD,GALJ,EAMLwD,QAAQ,CAACpJ,UANJ;EAFF,KAAP;EAWD,GArEM,CAAP;EAsED;EAEM,SAASoR,4BAAT,CAAsC/S,KAAtC,EAA6C;EAClD,MAAMsJ,UAAQ,GAAGtJ,KAAK,CAACI,MAAN,CAAaiO,MAAb,EAAjB;;EAEA,MAAMnO,IAAI,GAAGF,KAAK,CAACE,IAAnB;EAEA,MAAIyG,KAAK,GAAG,OAAZ;EAAA,MACIxG,UADJ;EAAA,MAEIgR,SAFJ;EAAA,MAGI9F,SAAS,GAAG,IAHhB;EAAA,MAIID,GAJJ;EAAA,MAKI0H,MALJ;EAOA,SAAO,IAAI9J,QAAJ,CAAa,SAASC,IAAT,GAAgB;EAClC,QAAIE,IAAJ;;EAEA,QAAIxC,KAAK,KAAK,OAAd,EAAuB;EACrBwC,MAAAA,IAAI,GAAGG,UAAQ,CAACL,IAAT,EAAP;EAEA,UAAIE,IAAI,CAACD,IAAL,KAAc,IAAlB,EACE,OAAOC,IAAP;EAEFhJ,MAAAA,UAAU,GAAGgJ,IAAI,CAACzI,KAAlB;EAEAiG,MAAAA,KAAK,GAAG,UAAR;EACA,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAItC,KAAK,KAAK,UAAd,EAA0B;EACxB,UAAIzG,IAAI,KAAK,YAAb,EAA2B;EACzByG,QAAAA,KAAK,GAAG,YAAR;EACA,eAAOsC,IAAI,EAAX;EACD;;EAEDmC,MAAAA,GAAG,GAAGjL,UAAU,CAACI,GAAjB;EACA4Q,MAAAA,SAAS,GAAGrR,MAAM,CAACwH,IAAP,CAAYnH,UAAU,CAACI,GAAvB,CAAZ;EACAuS,MAAAA,MAAM,GAAG,CAAT;EACAnM,MAAAA,KAAK,GAAG,gBAAR;EAEA,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAItC,KAAK,KAAK,YAAd,EAA4B;EAC1B,UAAIzG,IAAI,KAAK,UAAb,EAAyB;EACvByG,QAAAA,KAAK,GAAG,OAAR;EACA,eAAOsC,IAAI,EAAX;EACD;;EAEDmC,MAAAA,GAAG,GAAGjL,UAAU,CAACK,UAAjB;EACA2Q,MAAAA,SAAS,GAAGrR,MAAM,CAACwH,IAAP,CAAYnH,UAAU,CAACK,UAAvB,CAAZ;EACAsS,MAAAA,MAAM,GAAG,CAAT;EACAnM,MAAAA,KAAK,GAAG,kBAAR;EACD,KAvCiC;;;EA0ClC,QAAI,CAAC0E,SAAD,IAAcyH,MAAM,IAAI3B,SAAS,CAACxR,MAAtC,EAA8C;EAC5C,UAAIgH,KAAK,KAAK,kBAAd,EACEA,KAAK,GAAG,OAAR,CADF,KAGEA,KAAK,GAAG,YAAR;EAEF,aAAOsC,IAAI,EAAX;EACD;;EAED,QAAI,CAACoC,SAAL,EAAgB;EACd,UAAMW,QAAQ,GAAGmF,SAAS,CAAC2B,MAAM,EAAP,CAA1B;EACAzH,MAAAA,SAAS,GAAGD,GAAG,CAACY,QAAD,CAAH,CAAcqC,MAAd,EAAZ;EACA,aAAOpF,IAAI,EAAX;EACD;;EAEDE,IAAAA,IAAI,GAAGkC,SAAS,CAACpC,IAAV,EAAP;;EAEA,QAAIE,IAAI,CAACD,IAAT,EAAe;EACbmC,MAAAA,SAAS,GAAG,IAAZ;EACA,aAAOpC,IAAI,EAAX;EACD;;EAED,QAAM8B,QAAQ,GAAG5B,IAAI,CAACzI,KAAtB;EACA,QAAIsK,UAAU,GAAGD,QAAQ,CAACxL,MAA1B;EAEA,QAAIoH,KAAK,KAAK,kBAAV,IAAgCqE,UAAU,CAACzD,GAAX,KAAmBpH,UAAU,CAACoH,GAAlE,EACEyD,UAAU,GAAGD,QAAQ,CAAC9K,MAAtB;EAEF,WAAO;EACLiJ,MAAAA,IAAI,EAAE,KADD;EAELxI,MAAAA,KAAK,EAAE,CACLP,UAAU,CAACoH,GADN,EAELyD,UAAU,CAACzD,GAFN,EAGLpH,UAAU,CAACwB,UAHN,EAILqJ,UAAU,CAACrJ,UAJN,EAKLoJ,QAAQ,CAACxD,GALJ,EAMLwD,QAAQ,CAACpJ,UANJ;EAFF,KAAP;EAWD,GAjFM,CAAP;EAkFD;;EC9UD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASqR,aAAT,CAAuBzL,GAAvB,EAA4BuC,IAA5B,EAAkC;EACvC,MAAMmJ,UAAU,GAAG;EAAC1L,IAAAA,GAAG,EAAHA;EAAD,GAAnB;EAEA,MAAI,CAACxG,OAAO,CAAC+I,IAAI,CAACnI,UAAN,CAAZ,EACEsR,UAAU,CAACtR,UAAX,GAAwB9B,MAAM,CAAC,EAAD,EAAKiK,IAAI,CAACnI,UAAV,CAA9B;EAEF,SAAOsR,UAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;;EACO,SAASC,aAAT,CAAuB3L,GAAvB,EAA4BuC,IAA5B,EAAkC;EACvC,MAAMmJ,UAAU,GAAG;EACjBhT,IAAAA,MAAM,EAAE6J,IAAI,CAAC7J,MAAL,CAAYsH,GADH;EAEjBhI,IAAAA,MAAM,EAAEuK,IAAI,CAACvK,MAAL,CAAYgI;EAFH,GAAnB,CADuC;;EAOvC,MAAI,CAACuC,IAAI,CAACe,YAAV,EACEoI,UAAU,CAAC1L,GAAX,GAAiBA,GAAjB;EAEF,MAAI,CAACxG,OAAO,CAAC+I,IAAI,CAACnI,UAAN,CAAZ,EACEsR,UAAU,CAACtR,UAAX,GAAwB9B,MAAM,CAAC,EAAD,EAAKiK,IAAI,CAACnI,UAAV,CAA9B;EAEF,MAAImI,IAAI,CAACtJ,UAAT,EACEyS,UAAU,CAACzS,UAAX,GAAwB,IAAxB;EAEF,SAAOyS,UAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASE,sBAAT,CAAgCzS,KAAhC,EAAuC;EAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EACE,OAAO,YAAP;EAEF,MAAI,EAAE,SAASA,KAAX,CAAJ,EACE,OAAO,QAAP;EAEF,MAAI,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAACiB,UAAP,CAAd,IAAoCjB,KAAK,CAACiB,UAAN,KAAqB,IAD1D,CAAJ,EAEE,OAAO,oBAAP;EAEF,SAAO,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;;EACO,SAASyR,sBAAT,CAAgC1S,KAAhC,EAAuC;EAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EACE,OAAO,YAAP;EAEF,MAAI,EAAE,YAAYA,KAAd,CAAJ,EACE,OAAO,WAAP;EAEF,MAAI,EAAE,YAAYA,KAAd,CAAJ,EACE,OAAO,WAAP;EAEF,MAAI,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAACiB,UAAP,CAAd,IAAoCjB,KAAK,CAACiB,UAAN,KAAqB,IAD1D,CAAJ,EAEE,OAAO,oBAAP;EAEF,MAAI,gBAAgBjB,KAAhB,IACC,OAAOA,KAAK,CAACF,UAAb,KAA4B,SADjC,EAEE,OAAO,oBAAP;EAEF,SAAO,IAAP;EACD;;EC9CD;EACA;EACA;;EACA,IAAM6S,KAAK,GAAG,IAAI/H,GAAJ,CAAQ,CACpB,UADoB,EAEpB,YAFoB,EAGpB,OAHoB,CAAR,CAAd;EAMA,IAAMgI,aAAa,GAAG,IAAIhI,GAAJ,CAAQ,CAC5B,QAD4B,EAE5B,SAF4B,EAG5B,cAH4B,EAI5B,eAJ4B,CAAR,CAAtB;EAOA,IAAMiI,gBAAgB,GAAG,CACvB;EACErS,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA,GADZ;EAEEC,EAAAA,WAAW,EAAE;EAFf,CADuB,EAKvB;EACEvS,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA,GADZ;EAEEC,EAAAA,WAAW,EAAE,IAFf;EAGEvT,EAAAA,IAAI,EAAE;EAHR,CALuB,EAUvB;EACEgB,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA,GADZ;EAEEC,EAAAA,WAAW,EAAE,IAFf;EAGEvT,EAAAA,IAAI,EAAE;EAHR,CAVuB,EAevB;EACEgB,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA;EADZ,CAfuB,EAkBvB;EACEtS,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA,GADZ;EAEEtT,EAAAA,IAAI,EAAE;EAFR,CAlBuB,EAsBvB;EACEgB,EAAAA,IAAI,EAAE,cAAAsS,IAAI;EAAA,qBAAOA,IAAP;EAAA,GADZ;EAEEtT,EAAAA,IAAI,EAAE;EAFR,CAtBuB,CAAzB;EA4BA;EACA;EACA;;EACA,IAAMwT,QAAQ,GAAG;EACfC,EAAAA,cAAc,EAAE,IADD;EAEfC,EAAAA,gBAAgB,EAAE,IAFH;EAGf3I,EAAAA,KAAK,EAAE,KAHQ;EAIf/K,EAAAA,IAAI,EAAE;EAJS,CAAjB;EAOA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,SAAS2T,QAAT,CAAiB7T,KAAjB,EAAwB+L,IAAxB,EAA8BpK,UAA9B,EAA0C;EACxC,MAAIA,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIoI,0BAAJ,4EAAkGpI,UAAlG,QAAN,CAFsC;;EAKxCoK,EAAAA,IAAI,GAAG,KAAKA,IAAZ;EACApK,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;EAEA,MAAI3B,KAAK,CAACI,MAAN,CAAaoQ,GAAb,CAAiBzE,IAAjB,CAAJ,EACE,MAAM,IAAI7B,eAAJ,gCAA2C6B,IAA3C,yCAAN;EAEF,MAAMjC,IAAI,GAAG,IAAI9J,KAAK,CAAC8T,aAAV,CAAwB/H,IAAxB,EAA8BpK,UAA9B,CAAb,CAXwC;;EAcxC3B,EAAAA,KAAK,CAACI,MAAN,CAAa4D,GAAb,CAAiB+H,IAAjB,EAAuBjC,IAAvB,EAdwC;;;EAiBxC9J,EAAAA,KAAK,CAAC0E,IAAN,CAAW,WAAX,EAAwB;EACtB6C,IAAAA,GAAG,EAAEwE,IADiB;EAEtBpK,IAAAA,UAAU,EAAVA;EAFsB,GAAxB;EAKA,SAAOmI,IAAP;EACD;EAED;EACA;EACA;EACA;;;EACA,SAASiK,aAAT,CAAuB/T,KAAvB,EAA8B+L,IAA9B,EAAoCpK,UAApC,EAAgD;EAC9C,MAAMmI,IAAI,GAAG,IAAI9J,KAAK,CAAC8T,aAAV,CAAwB/H,IAAxB,EAA8BpK,UAA9B,CAAb;;EAEA3B,EAAAA,KAAK,CAACI,MAAN,CAAa4D,GAAb,CAAiB+H,IAAjB,EAAuBjC,IAAvB;;EAEA9J,EAAAA,KAAK,CAAC0E,IAAN,CAAW,WAAX,EAAwB;EACtB6C,IAAAA,GAAG,EAAEwE,IADiB;EAEtBpK,IAAAA,UAAU,EAAVA;EAFsB,GAAxB;EAKA,SAAOmI,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASkK,OAAT,CACEhU,KADF,EAEEkB,IAFF,EAGE+S,eAHF,EAIEzT,UAJF,EAKEF,IALF,EAMEL,MANF,EAOEV,MAPF,EAQEoC,UARF,EASE;EAEA;EACA,MAAI,CAACnB,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIgK,eAAJ,iBAA6BhJ,IAA7B,gHAAN;EAEF,MAAIV,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIgK,eAAJ,iBAA6BhJ,IAA7B,8GAAN;EAEF,MAAIS,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIoI,0BAAJ,iBAAwC7I,IAAxC,iEAAkGS,UAAlG,QAAN,CAVF;;EAaA1B,EAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,EAAAA,MAAM,GAAG,KAAKA,MAAd;EACAoC,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;EAEA,MAAI,CAAC3B,KAAK,CAAC2T,cAAP,IAAyB1T,MAAM,KAAKV,MAAxC,EACE,MAAM,IAAI2K,eAAJ,iBAA6BhJ,IAA7B,+CAAqEjB,MAArE,wGAAN;;EAEF,MAAME,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAnB;EAAA,MACM+K,UAAU,GAAGhL,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBd,MAAjB,CADnB;;EAGA,MAAI,CAACY,UAAL,EACE,MAAM,IAAI8J,kBAAJ,iBAAgC/I,IAAhC,6BAAsDjB,MAAtD,mBAAN;EAEF,MAAI,CAAC+K,UAAL,EACE,MAAM,IAAIf,kBAAJ,iBAAgC/I,IAAhC,6BAAsD3B,MAAtD,mBAAN,CA3BF;;EA8BA,MAAM2U,SAAS,GAAG;EAChB3M,IAAAA,GAAG,EAAE,IADW;EAEhB/G,IAAAA,UAAU,EAAVA,UAFgB;EAGhBP,IAAAA,MAAM,EAANA,MAHgB;EAIhBV,IAAAA,MAAM,EAANA,MAJgB;EAKhBoC,IAAAA,UAAU,EAAVA;EALgB,GAAlB;EAQA,MAAIsS,eAAJ,EACE3T,IAAI,GAAGN,KAAK,CAACmU,iBAAN,CAAwBD,SAAxB,CAAP,CAvCF;;EA0CA5T,EAAAA,IAAI,GAAG,KAAKA,IAAZ,CA1CA;;EA6CA,MAAIN,KAAK,CAACsM,MAAN,CAAakE,GAAb,CAAiBlQ,IAAjB,CAAJ,EACE,MAAM,IAAI4J,eAAJ,iBAA6BhJ,IAA7B,qBAA2CZ,IAA3C,0CAAN,CA9CF;;EAiDA,MACE,CAACN,KAAK,CAACiL,KAAP,KAEEzK,UAAU,GACR,OAAOL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAAP,KAAyC,WADjC,GAER,OAAOY,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAP,KAAkC,WAJtC,CADF,EAOE;EACA,UAAM,IAAI2K,eAAJ,iBAA6BhJ,IAA7B,iCAAuDjB,MAAvD,qBAAsEV,MAAtE,mJAAN;EACD,GA1DD;;;EA6DA,MAAMwL,QAAQ,GAAG,IAAIH,QAAJ,CACfpK,UADe,EAEfF,IAFe,EAGf2T,eAHe,EAIf9T,UAJe,EAKf6K,UALe,EAMfrJ,UANe,CAAjB,CA7DA;;EAuEA3B,EAAAA,KAAK,CAACsM,MAAN,CAAatI,GAAb,CAAiB1D,IAAjB,EAAuByK,QAAvB,EAvEA;;;EA0EA,MAAI9K,MAAM,KAAKV,MAAf,EAAuB;EACrB,QAAIiB,UAAJ,EAAgB;EACdL,MAAAA,UAAU,CAACqK,mBAAX;EACAxK,MAAAA,KAAK,CAACoU,wBAAN;EACD,KAHD,MAIK;EACHjU,MAAAA,UAAU,CAACoK,iBAAX;EACAvK,MAAAA,KAAK,CAACqU,sBAAN;EACD;EACF,GATD,MAUK;EACH,QAAI7T,UAAJ,EAAgB;EACdL,MAAAA,UAAU,CAACmK,gBAAX;EACAU,MAAAA,UAAU,CAACV,gBAAX;EACD,KAHD,MAIK;EACHnK,MAAAA,UAAU,CAACkK,SAAX;EACAW,MAAAA,UAAU,CAACZ,QAAX;EACD;EACF,GA7FD;;;EAgGAU,EAAAA,oBAAoB,CAClB9K,KADkB,EAElBQ,UAFkB,EAGlBuK,QAHkB,EAIlB9K,MAJkB,EAKlBV,MALkB,EAMlBY,UANkB,EAOlB6K,UAPkB,CAApB;EAUA,MAAIxK,UAAJ,EACER,KAAK,CAACsU,eAAN,GADF,KAGEtU,KAAK,CAACuU,aAAN,GA7GF;;EAgHAL,EAAAA,SAAS,CAAC3M,GAAV,GAAgBjH,IAAhB;EAEAN,EAAAA,KAAK,CAAC0E,IAAN,CAAW,WAAX,EAAwBwP,SAAxB;EAEA,SAAO5T,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASkU,SAAT,CACExU,KADF,EAEEkB,IAFF,EAGE+S,eAHF,EAIEzT,UAJF,EAKEF,IALF,EAMEL,MANF,EAOEV,MAPF,EAQEoC,UARF,EASE8S,SATF,EAUE;EAEA;EACA,MAAI,CAACjU,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIgK,eAAJ,iBAA6BhJ,IAA7B,gHAAN;EAEF,MAAIV,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIgK,eAAJ,iBAA6BhJ,IAA7B,8GAAN;;EAEF,MAAIS,UAAJ,EAAgB;EACd,QAAI8S,SAAJ,EAAe;EACb,UAAI,OAAO9S,UAAP,KAAsB,UAA1B,EACE,MAAM,IAAIoI,0BAAJ,iBAAwC7I,IAAxC,wEAAyGS,UAAzG,QAAN;EACH,KAHD,MAIK;EACH,UAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,iBAAwC7I,IAAxC,iEAAkGS,UAAlG,QAAN;EACH;EACF,GAlBD;;;EAqBA1B,EAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,EAAAA,MAAM,GAAG,KAAKA,MAAd;EAEA,MAAIqN,OAAJ;;EAEA,MAAI6H,SAAJ,EAAe;EACb7H,IAAAA,OAAO,GAAGjL,UAAV;EACAA,IAAAA,UAAU,GAAG8B,SAAb;EACD;;EAED,MAAI,CAACzD,KAAK,CAAC2T,cAAP,IAAyB1T,MAAM,KAAKV,MAAxC,EACE,MAAM,IAAI2K,eAAJ,iBAA6BhJ,IAA7B,+CAAqEjB,MAArE,wGAAN;;EAEF,MAAIE,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAjB;EAAA,MACI+K,UAAU,GAAGhL,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBd,MAAjB,CADjB;EAAA,MAEIwL,QAFJ,CAlCA;;;EAuCA,MAAI2J,uBAAJ;;EAEA,MAAI,CAACT,eAAL,EAAsB;EACpBlJ,IAAAA,QAAQ,GAAG/K,KAAK,CAACsM,MAAN,CAAajM,GAAb,CAAiBC,IAAjB,CAAX;;EAEA,QAAIyK,QAAJ,EAAc;EAEZ;EACA;EACA,UACGA,QAAQ,CAAC9K,MAAT,CAAgBsH,GAAhB,KAAwBtH,MAAxB,IAAkC8K,QAAQ,CAACxL,MAAT,CAAgBgI,GAAhB,KAAwBhI,MAA3D,IACCiB,UAAU,KAAKuK,QAAQ,CAAC9K,MAAT,CAAgBsH,GAAhB,KAAwBhI,MAAxB,IAAkCwL,QAAQ,CAACxL,MAAT,CAAgBgI,GAAhB,KAAwBtH,MAA/D,CAFb,EAGE;EACA,cAAM,IAAIiK,eAAJ,iBAA6BhJ,IAA7B,qEAA2FZ,IAA3F,4BAA+GL,MAA/G,2BAAoIV,MAApI,8BAA4JwL,QAAQ,CAAC9K,MAAT,CAAgBsH,GAA5K,mBAAsLwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAAtM,UAAN;EACD;;EAEDmN,MAAAA,uBAAuB,GAAG3J,QAA1B;EACD;EACF,GAzDD;;;EA4DA,MACE,CAAC2J,uBAAD,IACA,CAAC1U,KAAK,CAACiL,KADP,IAEA9K,UAHF,EAIE;EACAuU,IAAAA,uBAAuB,GAAGlU,UAAU,GAClCL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CADkC,GAElCY,UAAU,CAACI,GAAX,CAAehB,MAAf,CAFF;EAGD,GApED;;;EAuEA,MAAImV,uBAAJ,EAA6B;EAE3B;EACA,QAAID,SAAS,GAAG,CAAC7H,OAAJ,GAAc,CAACjL,UAA5B,EACE,OAAO+S,uBAAuB,CAACnN,GAA/B,CAJyB;;EAO3B,QAAIkN,SAAJ,EAAe;EACb,UAAME,aAAa,GAAGD,uBAAuB,CAAC/S,UAA9C;EACA+S,MAAAA,uBAAuB,CAAC/S,UAAxB,GAAqCiL,OAAO,CAAC+H,aAAD,CAA5C;EAEA3U,MAAAA,KAAK,CAAC0E,IAAN,CAAW,uBAAX,EAAoC;EAClCxE,QAAAA,IAAI,EAAE,SAD4B;EAElCqH,QAAAA,GAAG,EAAEmN,uBAAuB,CAACnN,GAFK;EAGlC5F,QAAAA,UAAU,EAAE+S,uBAAuB,CAAC/S;EAHF,OAApC;EAKD,KATD;EAAA,SAYK;EACH9B,MAAAA,MAAM,CAAC6U,uBAAuB,CAAC/S,UAAzB,EAAqCA,UAArC,CAAN;EAEA3B,MAAAA,KAAK,CAAC0E,IAAN,CAAW,uBAAX,EAAoC;EAClCxE,QAAAA,IAAI,EAAE,OAD4B;EAElCqH,QAAAA,GAAG,EAAEmN,uBAAuB,CAACnN,GAFK;EAGlC5F,QAAAA,UAAU,EAAE+S,uBAAuB,CAAC/S,UAHF;EAIlCmI,QAAAA,IAAI,EAAEnI;EAJ4B,OAApC;EAMD;;EAED,WAAO+S,uBAAuB,CAACnN,GAA/B;EACD;;EAED5F,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;EAEA,MAAI8S,SAAS,IAAI7H,OAAjB,EACEjL,UAAU,GAAGiL,OAAO,CAACjL,UAAD,CAApB,CA3GF;;EA8GA,MAAMuS,SAAS,GAAG;EAChB3M,IAAAA,GAAG,EAAE,IADW;EAEhB/G,IAAAA,UAAU,EAAVA,UAFgB;EAGhBP,IAAAA,MAAM,EAANA,MAHgB;EAIhBV,IAAAA,MAAM,EAANA,MAJgB;EAKhBoC,IAAAA,UAAU,EAAVA;EALgB,GAAlB;EAQA,MAAIsS,eAAJ,EACE3T,IAAI,GAAGN,KAAK,CAACmU,iBAAN,CAAwBD,SAAxB,CAAP,CAvHF;;EA0HA5T,EAAAA,IAAI,GAAG,KAAKA,IAAZ,CA1HA;;EA6HA,MAAIN,KAAK,CAACsM,MAAN,CAAakE,GAAb,CAAiBlQ,IAAjB,CAAJ,EACE,MAAM,IAAI4J,eAAJ,iBAA6BhJ,IAA7B,qBAA2CZ,IAA3C,0CAAN;;EAEF,MAAI,CAACH,UAAL,EAAiB;EACfA,IAAAA,UAAU,GAAG4T,aAAa,CAAC/T,KAAD,EAAQC,MAAR,EAAgB,EAAhB,CAA1B;EAEA,QAAIA,MAAM,KAAKV,MAAf,EACEyL,UAAU,GAAG7K,UAAb;EACH;;EACD,MAAI,CAAC6K,UAAL,EAAiB;EACfA,IAAAA,UAAU,GAAG+I,aAAa,CAAC/T,KAAD,EAAQT,MAAR,EAAgB,EAAhB,CAA1B;EACD,GAxID;;;EA2IAwL,EAAAA,QAAQ,GAAG,IAAIH,QAAJ,CACTpK,UADS,EAETF,IAFS,EAGT2T,eAHS,EAIT9T,UAJS,EAKT6K,UALS,EAMTrJ,UANS,CAAX,CA3IA;;EAqJA3B,EAAAA,KAAK,CAACsM,MAAN,CAAatI,GAAb,CAAiB1D,IAAjB,EAAuByK,QAAvB,EArJA;;;EAwJA,MAAI9K,MAAM,KAAKV,MAAf,EAAuB;EACrB,QAAIiB,UAAJ,EAAgB;EACdL,MAAAA,UAAU,CAACqK,mBAAX;EACAxK,MAAAA,KAAK,CAACoU,wBAAN;EACD,KAHD,MAIK;EACHjU,MAAAA,UAAU,CAACoK,iBAAX;EACAvK,MAAAA,KAAK,CAACqU,sBAAN;EACD;EACF,GATD,MAUK;EACH,QAAI7T,UAAJ,EAAgB;EACdL,MAAAA,UAAU,CAACmK,gBAAX;EACAU,MAAAA,UAAU,CAACV,gBAAX;EACD,KAHD,MAIK;EACHnK,MAAAA,UAAU,CAACkK,SAAX;EACAW,MAAAA,UAAU,CAACZ,QAAX;EACD;EACF,GA3KD;;;EA8KAU,EAAAA,oBAAoB,CAClB9K,KADkB,EAElBQ,UAFkB,EAGlBuK,QAHkB,EAIlB9K,MAJkB,EAKlBV,MALkB,EAMlBY,UANkB,EAOlB6K,UAPkB,CAApB;EAUA,MAAIxK,UAAJ,EACER,KAAK,CAACsU,eAAN,GADF,KAGEtU,KAAK,CAACuU,aAAN,GA3LF;;EA8LAL,EAAAA,SAAS,CAAC3M,GAAV,GAAgBjH,IAAhB;EAEAN,EAAAA,KAAK,CAAC0E,IAAN,CAAW,WAAX,EAAwBwP,SAAxB;EAEA,SAAO5T,IAAP;EACD;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;MACqB6M;;;EACnB,iBAAYyH,OAAZ,EAAqB;EAAA;;EACnB,6CADmB;;EAInBA,IAAAA,OAAO,GAAG/U,MAAM,CAAC,EAAD,EAAK6T,QAAL,EAAekB,OAAf,CAAhB,CAJmB;;EAOnB,QAAIA,OAAO,CAAChB,gBAAR,IAA4B,OAAOgB,OAAO,CAAChB,gBAAf,KAAoC,UAApE,EACE,MAAM,IAAI7J,0BAAJ,gGAAsH6K,OAAO,CAAChB,gBAA9H,SAAN;EAEF,QAAI,OAAOgB,OAAO,CAAC3J,KAAf,KAAyB,SAA7B,EACE,MAAM,IAAIlB,0BAAJ,oFAA0G6K,OAAO,CAAC3J,KAAlH,SAAN;EAEF,QAAI,CAACoI,KAAK,CAAC7C,GAAN,CAAUoE,OAAO,CAAC1U,IAAlB,CAAL,EACE,MAAM,IAAI6J,0BAAJ,0HAA0I6K,OAAO,CAAC1U,IAAlJ,SAAN;EAEF,QAAI,OAAO0U,OAAO,CAACjB,cAAf,KAAkC,SAAtC,EACE,MAAM,IAAI5J,0BAAJ,6FAAmH6K,OAAO,CAACjB,cAA3H,SAAN,CAjBiB;EAqBnB;;EACA,QAAMG,aAAa,GAAGc,OAAO,CAAC1U,IAAR,KAAiB,OAAjB,GACpBiK,aADoB,GAEnByK,OAAO,CAAC1U,IAAR,KAAiB,UAAlB,GACEuK,gBADF,GAEEE,kBAJJ;EAMA1J,IAAAA,eAAe,gCAAO,eAAP,EAAwB6S,aAAxB,CAAf,CA5BmB;;EA+BnB7S,IAAAA,eAAe,gCAAO,aAAP,EAAsB,EAAtB,CAAf;EACAA,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAI4T,GAAJ,EAAjB,CAAf;EACA5T,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAI4T,GAAJ,EAAjB,CAAf;EACA5T,IAAAA,eAAe,gCAAO,eAAP,EAAwB,CAAxB,CAAf;EACAA,IAAAA,eAAe,gCAAO,iBAAP,EAA0B,CAA1B,CAAf;EACAA,IAAAA,eAAe,gCAAO,wBAAP,EAAiC,CAAjC,CAAf;EACAA,IAAAA,eAAe,gCAAO,0BAAP,EAAmC,CAAnC,CAAf;EACAA,IAAAA,eAAe,gCAAO,mBAAP,EAA4B2T,OAAO,CAAChB,gBAAR,IAA4B9R,aAAa,EAArE,CAAf,CAtCmB;;EAyCnBb,IAAAA,eAAe,gCAAO,UAAP,EAAmB2T,OAAnB,CAAf,CAzCmB;;EA4CnBtB,IAAAA,aAAa,CAACzH,OAAd,CAAsB,UAAAiJ,IAAI;EAAA,aAAI7T,eAAe,gCAAO6T,IAAP,EAAa,MAAKA,IAAL,CAAb,CAAnB;EAAA,KAA1B,EA5CmB;;EA+CnBvT,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB;EAAA,aAAM,MAAKnB,MAAL,CAAYsL,IAAlB;EAAA,KAAhB,CAAhB;EACAnK,IAAAA,gBAAgB,gCAAO,MAAP,EAAe;EAAA,aAAM,MAAK+K,MAAL,CAAYZ,IAAlB;EAAA,KAAf,CAAhB;EACAnK,IAAAA,gBAAgB,gCAAO,cAAP,EAAuB;EAAA,aAAM,MAAKgT,aAAX;EAAA,KAAvB,CAAhB;EACAhT,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB;EAAA,aAAM,MAAK+S,eAAX;EAAA,KAAzB,CAAhB;EACA/S,IAAAA,gBAAgB,gCAAO,eAAP,EAAwB;EAAA,aAAM,MAAK8S,sBAAL,GAA8B,MAAKD,wBAAzC;EAAA,KAAxB,CAAhB;EACA7S,IAAAA,gBAAgB,gCAAO,uBAAP,EAAgC;EAAA,aAAM,MAAK8S,sBAAX;EAAA,KAAhC,CAAhB;EACA9S,IAAAA,gBAAgB,gCAAO,yBAAP,EAAkC;EAAA,aAAM,MAAK6S,wBAAX;EAAA,KAAlC,CAAhB;EACA7S,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB,MAAKwT,QAAL,CAAc9J,KAA9B,CAAhB;EACA1J,IAAAA,gBAAgB,gCAAO,MAAP,EAAe,MAAKwT,QAAL,CAAc7U,IAA7B,CAAhB;EACAqB,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB,MAAKwT,QAAL,CAAcpB,cAAvC,CAAhB;EACApS,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB;EAAA,aAAM,YAAN;EAAA,KAAzB,CAAhB;EAzDmB;EA0DpB;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;EACA;;;;;WACEyT,UAAA,iBAAQjJ,IAAR,EAAc;EACZ,WAAO,KAAK3L,MAAL,CAAYoQ,GAAZ,CAAgB,KAAKzE,IAArB,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEkJ,kBAAA,yBAAgBhV,MAAhB,EAAwBV,MAAxB,EAAgC;EAE9B;EACA,QAAI,KAAKW,IAAL,KAAc,YAAlB,EACE,OAAO,KAAP;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;;EAEA,UAAM8K,QAAQ,GAAG,KAAKuB,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAjB;;EAEA,aACE,CAAC,CAACyK,QAAF,IACA,CAACA,QAAQ,CAACvK,UAFZ;EAID,KATD,MAUK,IAAIhB,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAE/BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;EAM/B,UAAMoQ,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,CAAC0P,QAAL,EACE,OAAO,KAAP,CAT6B;;EAY/B,UAAM1D,KAAK,GAAG0D,QAAQ,CAACpP,GAAT,CAAahB,MAAb,CAAd;EAEA,UAAI,CAAC0M,KAAL,EACE,OAAO,KAAP;EAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;EACD;;EAED,UAAM,IAAI3B,0BAAJ,iDAAwEvK,SAAS,CAACG,MAAlF,0HAAN;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEuV,oBAAA,2BAAkBjV,MAAlB,EAA0BV,MAA1B,EAAkC;EAEhC;EACA,QAAI,KAAKW,IAAL,KAAc,UAAlB,EACE,OAAO,KAAP;;EAEF,QAAIV,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;;EAEA,UAAM8K,QAAQ,GAAG,KAAKuB,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAjB;;EAEA,aACE,CAAC,CAACyK,QAAF,IACAA,QAAQ,CAACvK,UAFX;EAID,KATD,MAUK,IAAIhB,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAE/BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;EAM/B,UAAMoQ,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,CAAC0P,QAAL,EACE,OAAO,KAAP,CAT6B;;EAY/B,UAAM1D,KAAK,GAAG0D,QAAQ,CAACnP,UAAT,CAAoBjB,MAApB,CAAd;EAEA,UAAI,CAAC0M,KAAL,EACE,OAAO,KAAP;EAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;EACD;;EAED,UAAM,IAAI3B,0BAAJ,iDAAwEvK,SAAS,CAACG,MAAlF,0HAAN;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEwV,UAAA,iBAAQlV,MAAR,EAAgBV,MAAhB,EAAwB;EAEtB,QAAIC,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAC1B,UAAMW,IAAI,GAAG,KAAKL,MAAlB;EAEA,aAAO,KAAKqM,MAAL,CAAYkE,GAAZ,CAAgBlQ,IAAhB,CAAP;EACD,KAJD,MAKK,IAAId,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;EAE/BM,MAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;EAM/B,UAAMoQ,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;EAEA,UAAI,CAAC0P,QAAL,EACE,OAAO,KAAP,CAT6B;;EAY/B,UAAI1D,KAAK,GAAG,OAAO0D,QAAQ,CAACpP,GAAhB,KAAwB,WAAxB,IAAuCoP,QAAQ,CAACpP,GAAT,CAAahB,MAAb,CAAnD;EAEA,UAAI,CAAC0M,KAAL,EACEA,KAAK,GAAG,OAAO0D,QAAQ,CAACnP,UAAhB,KAA+B,WAA/B,IAA8CmP,QAAQ,CAACnP,UAAT,CAAoBjB,MAApB,CAAtD;EAEF,UAAI,CAAC0M,KAAL,EACE,OAAO,KAAP;EAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;EACD;;EAED,UAAM,IAAI3B,0BAAJ,yCAAgEvK,SAAS,CAACG,MAA1E,0HAAN;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEyV,eAAA,sBAAanV,MAAb,EAAqBV,MAArB,EAA6B;EAE3B,QAAI,KAAKW,IAAL,KAAc,YAAlB,EACE;EAEFD,IAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;EAEA,QAAI,KAAK0L,KAAT,EACE,MAAM,IAAIf,eAAJ,CAAoB,0JAApB,CAAN;;EAEF,QAAM/J,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,oDAAkEhK,MAAlE,kCAAN;EAEF,QAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,oDAAkE1K,MAAlE,kCAAN;EAEF,QAAMwL,QAAQ,GAAI5K,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAnB,IAA8CkE,SAA/D;EAEA,QAAIsH,QAAJ,EACE,OAAOA,QAAQ,CAACxD,GAAhB;EACH;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE8N,iBAAA,wBAAepV,MAAf,EAAuBV,MAAvB,EAA+B;EAE7B,QAAI,KAAKW,IAAL,KAAc,UAAlB,EACE;EAEFD,IAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;EAEA,QAAI,KAAK0L,KAAT,EACE,MAAM,IAAIf,eAAJ,CAAoB,8JAApB,CAAN;;EAEF,QAAM/J,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,sDAAoEhK,MAApE,kCAAN;EAEF,QAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,sDAAoE1K,MAApE,kCAAN;EAEF,QAAMwL,QAAQ,GAAI5K,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAA1B,IAA4DkE,SAA7E;EAEA,QAAIsH,QAAJ,EACE,OAAOA,QAAQ,CAACxD,GAAhB;EACH;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEjH,OAAA,cAAKL,MAAL,EAAaV,MAAb,EAAqB;EACnB,QAAI,KAAK0L,KAAT,EACE,MAAM,IAAIf,eAAJ,CAAoB,0IAApB,CAAN;EAEFjK,IAAAA,MAAM,GAAG,KAAKA,MAAd;EACAV,IAAAA,MAAM,GAAG,KAAKA,MAAd;;EAEA,QAAMY,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;EAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAI8J,kBAAJ,4CAA0DhK,MAA1D,kCAAN;EAEF,QAAI,CAAC,KAAKG,MAAL,CAAYoQ,GAAZ,CAAgBjR,MAAhB,CAAL,EACE,MAAM,IAAI0K,kBAAJ,4CAA0D1K,MAA1D,kCAAN;EAEF,QAAMwL,QAAQ,GACX5K,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAehB,MAAf,CAAnB,IACCY,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBjB,MAAtB,CAD1B,IAEAkE,SAHF;EAMA,QAAIsH,QAAJ,EACE,OAAOA,QAAQ,CAACxD,GAAhB;EACH;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE6C,WAAA,kBAAS2B,IAAT,EAAiC;EAAA,QAAlBuJ,SAAkB,uEAAN,IAAM;EAC/B,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAIvL,0BAAJ,yDAA+EuL,SAA/E,sEAAN;EAEFvJ,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,gDAA8D8B,IAA9D,2BAAN;EAEF,QAAI,KAAK7L,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;EAEF,QAAMqV,KAAK,GAAGD,SAAS,GAAG3F,QAAQ,CAACpF,iBAAZ,GAAgC,CAAvD;EAEA,WAAOoF,QAAQ,CAACvF,QAAT,GAAoBmL,KAA3B;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACElL,YAAA,mBAAU0B,IAAV,EAAkC;EAAA,QAAlBuJ,SAAkB,uEAAN,IAAM;EAChC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAIvL,0BAAJ,0DAAgFuL,SAAhF,sEAAN;EAEFvJ,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,iDAA+D8B,IAA/D,2BAAN;EAEF,QAAI,KAAK7L,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;EAEF,QAAMqV,KAAK,GAAGD,SAAS,GAAG3F,QAAQ,CAACpF,iBAAZ,GAAgC,CAAvD;EAEA,WAAOoF,QAAQ,CAACtF,SAAT,GAAqBkL,KAA5B;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEC,iBAAA,wBAAezJ,IAAf,EAAuC;EAAA,QAAlBuJ,SAAkB,uEAAN,IAAM;EACrC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAIvL,0BAAJ,+DAAqFuL,SAArF,sEAAN;EAEFvJ,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,sDAAoE8B,IAApE,2BAAN;EAEF,QAAI,KAAK7L,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;EAEF,QAAMqV,KAAK,GAAGD,SAAS,GAAG3F,QAAQ,CAACpF,iBAAZ,GAAgC,CAAvD;EAEA,QAAMH,QAAQ,GAAGuF,QAAQ,CAACvF,QAAT,GAAoBmL,KAArC;EACA,QAAMlL,SAAS,GAAGsF,QAAQ,CAACtF,SAAT,GAAqBkL,KAAvC;EAEA,WAAOnL,QAAQ,GAAGC,SAAlB;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEC,mBAAA,0BAAiByB,IAAjB,EAAyC;EAAA,QAAlBuJ,SAAkB,uEAAN,IAAM;EACvC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAIvL,0BAAJ,iEAAuFuL,SAAvF,sEAAN;EAEFvJ,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,wDAAsE8B,IAAtE,2BAAN;EAEF,QAAI,KAAK7L,IAAL,KAAc,UAAlB,EACE,OAAO,CAAP;EAEF,QAAMqV,KAAK,GAAGD,SAAS,GAAG3F,QAAQ,CAACnF,mBAAZ,GAAkC,CAAzD;EAEA,WAAOmF,QAAQ,CAACrF,gBAAT,GAA4BiL,KAAK,GAAG,CAA3C;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEE,SAAA,gBAAO1J,IAAP,EAA+B;EAAA,QAAlBuJ,SAAkB,uEAAN,IAAM;EAC7B,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAIvL,0BAAJ,uDAA6EuL,SAA7E,sEAAN;EAEFvJ,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,8CAA4D8B,IAA5D,2BAAN;EAEF,QAAI0J,MAAM,GAAG,CAAb;EACA,QAAIF,KAAK,GAAG,CAAZ;;EAEA,QAAI,KAAKrV,IAAL,KAAc,UAAlB,EAA8B;EAC5B,UAAIoV,SAAJ,EACEC,KAAK,GAAG5F,QAAQ,CAACnF,mBAAjB;EAEFiL,MAAAA,MAAM,IAAI9F,QAAQ,CAACrF,gBAAT,GAA4BiL,KAAK,GAAG,CAA9C;EACD;;EAED,QAAI,KAAKrV,IAAL,KAAc,YAAlB,EAAgC;EAC9B,UAAIoV,SAAJ,EACEC,KAAK,GAAG5F,QAAQ,CAACpF,iBAAjB;EAEFkL,MAAAA,MAAM,IAAI9F,QAAQ,CAACvF,QAAT,GAAoBuF,QAAQ,CAACtF,SAA7B,GAAyCkL,KAAK,GAAG,CAA3D;EACD;;EAED,WAAOE,MAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACExV,SAAA,gBAAOK,IAAP,EAAa;EACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,8CAA4D3J,IAA5D,2BAAN;EAEF,WAAOwJ,IAAI,CAAC7J,MAAL,CAAYsH,GAAnB;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEhI,SAAA,gBAAOe,IAAP,EAAa;EACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,8CAA4D3J,IAA5D,2BAAN;EAEF,WAAOwJ,IAAI,CAACvK,MAAL,CAAYgI,GAAnB;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEmO,cAAA,qBAAYpV,IAAZ,EAAkB;EAChBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMyK,QAAQ,GAAG,KAAKuB,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAjB;;EAEA,QAAI,CAACyK,QAAL,EACE,MAAM,IAAId,kBAAJ,mDAAiE3J,IAAjE,2BAAN;EAEF,WAAO,CACLyK,QAAQ,CAAC9K,MAAT,CAAgBsH,GADX,EAELwD,QAAQ,CAACxL,MAAT,CAAgBgI,GAFX,CAAP;EAID;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEoO,WAAA,kBAAS5J,IAAT,EAAezL,IAAf,EAAqB;EACnByL,IAAAA,IAAI,GAAG,KAAKA,IAAZ;EACAzL,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,gDAA8D3J,IAA9D,2BAAN;EAEF,QAAML,MAAM,GAAG6J,IAAI,CAAC7J,MAAL,CAAYsH,GAA3B;EAAA,QACMhI,MAAM,GAAGuK,IAAI,CAACvK,MAAL,CAAYgI,GAD3B;EAGA,QAAIwE,IAAI,KAAK9L,MAAT,IAAmB8L,IAAI,KAAKxM,MAAhC,EACE,MAAM,IAAI0K,kBAAJ,iCAA+C8B,IAA/C,8CAAqFzL,IAArF,sBAAoGL,MAApG,eAA+GV,MAA/G,QAAN;EAEF,WAAOwM,IAAI,KAAK9L,MAAT,GAAkBV,MAAlB,GAA2BU,MAAlC;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE2V,eAAA,sBAAatV,IAAb,EAAmByL,IAAnB,EAAyB;EACvBzL,IAAAA,IAAI,GAAG,KAAKA,IAAZ;EACAyL,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,oDAAkE3J,IAAlE,2BAAN;EAEF,WACEwJ,IAAI,CAAC7J,MAAL,CAAYsH,GAAZ,KAAoBwE,IAApB,IACAjC,IAAI,CAACvK,MAAL,CAAYgI,GAAZ,KAAoBwE,IAFtB;EAID;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE8J,eAAA,sBAAavV,IAAb,EAAmB;EACjBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,oDAAkE3J,IAAlE,2BAAN;EAEF,WAAOwJ,IAAI,CAACtJ,UAAZ;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEsV,aAAA,oBAAWxV,IAAX,EAAiB;EACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,kDAAgE3J,IAAhE,2BAAN;EAEF,WAAO,CAACwJ,IAAI,CAACtJ,UAAb;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEuV,aAAA,oBAAWzV,IAAX,EAAiB;EACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,kDAAgE3J,IAAhE,2BAAN;EAEF,WAAOwJ,IAAI,CAAC7J,MAAL,KAAgB6J,IAAI,CAACvK,MAA5B;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEyW,kBAAA,yBAAgB1V,IAAhB,EAAsB;EACpBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,uDAAqE3J,IAArE,2BAAN;EAEF,WAAOwJ,IAAI,CAACe,YAAZ;EACD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEgJ,UAAA,iBAAQ9H,IAAR,EAAcpK,UAAd,EAA0B;EACxB,QAAMgO,QAAQ,GAAGkE,QAAO,CAAC,IAAD,EAAO9H,IAAP,EAAapK,UAAb,CAAxB;;EAEA,WAAOgO,QAAQ,CAACpI,GAAhB;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACE0O,YAAA,mBAAUlK,IAAV,EAAgBpK,UAAhB,EAA4B;EAC1B,QAAIA,UAAU,IAAI,CAACd,aAAa,CAACc,UAAD,CAAhC,EACE,MAAM,IAAIoI,0BAAJ,8EAAoGpI,UAApG,QAAN,CAFwB;;EAK1BoK,IAAAA,IAAI,GAAG,KAAKA,IAAZ;EACApK,IAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B,CAN0B;;EAS1B,QAAImI,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAX;;EAEA,QAAIjC,IAAJ,EAAU;EACR,UAAInI,UAAJ,EAAgB;EACd9B,QAAAA,MAAM,CAACiK,IAAI,CAACnI,UAAN,EAAkBA,UAAlB,CAAN;EAEA,aAAK+C,IAAL,CAAU,uBAAV,EAAmC;EACjCxE,UAAAA,IAAI,EAAE,OAD2B;EAEjCqH,UAAAA,GAAG,EAAEwE,IAF4B;EAGjCpK,UAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCmI,UAAAA,IAAI,EAAEnI;EAJ2B,SAAnC;EAMD;;EACD,aAAOoK,IAAP;EACD;;EAEDjC,IAAAA,IAAI,GAAG,IAAI,KAAKgK,aAAT,CAAuB/H,IAAvB,EAA6BpK,UAA7B,CAAP,CAzB0B;;EA4B1B,SAAKvB,MAAL,CAAY4D,GAAZ,CAAgB+H,IAAhB,EAAsBjC,IAAtB,EA5B0B;;;EA+B1B,SAAKpF,IAAL,CAAU,WAAV,EAAuB;EACrB6C,MAAAA,GAAG,EAAEwE,IADgB;EAErBpK,MAAAA,UAAU,EAAVA;EAFqB,KAAvB;EAKA,WAAOoK,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEmK,aAAA,oBAAWnK,IAAX,EAAiBa,OAAjB,EAA0B;EACxB,QAAIA,OAAO,IAAI,OAAOA,OAAP,KAAmB,UAAlC,EACE,MAAM,IAAI7C,0BAAJ,sFAA4G6C,OAA5G,QAAN,CAFsB;;EAKxBb,IAAAA,IAAI,GAAG,KAAKA,IAAZ,CALwB;;EAQxB,QAAIjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAX;;EAEA,QAAIjC,IAAJ,EAAU;EACR,UAAI8C,OAAJ,EAAa;EACX,YAAM+H,aAAa,GAAG7K,IAAI,CAACnI,UAA3B;EACAmI,QAAAA,IAAI,CAACnI,UAAL,GAAkBiL,OAAO,CAAC+H,aAAD,CAAzB;EAEA,aAAKjQ,IAAL,CAAU,uBAAV,EAAmC;EACjCxE,UAAAA,IAAI,EAAE,SAD2B;EAEjCqH,UAAAA,GAAG,EAAEwE,IAF4B;EAGjCpK,UAAAA,UAAU,EAAEmI,IAAI,CAACnI;EAHgB,SAAnC;EAKD;;EACD,aAAOoK,IAAP;EACD;;EAED,QAAMpK,UAAU,GAAGiL,OAAO,GAAGA,OAAO,CAAC,EAAD,CAAV,GAAiB,EAA3C;EAEA9C,IAAAA,IAAI,GAAG,IAAI,KAAKgK,aAAT,CAAuB/H,IAAvB,EAA6BpK,UAA7B,CAAP,CA1BwB;;EA6BxB,SAAKvB,MAAL,CAAY4D,GAAZ,CAAgB+H,IAAhB,EAAsBjC,IAAtB,EA7BwB;;;EAgCxB,SAAKpF,IAAL,CAAU,WAAV,EAAuB;EACrB6C,MAAAA,GAAG,EAAEwE,IADgB;EAErBpK,MAAAA,UAAU,EAAVA;EAFqB,KAAvB;EAKA,WAAOoK,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEnL,WAAA,kBAASmL,IAAT,EAAe;EAAA;;EACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAM4D,QAAQ,GAAG,KAAKvP,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAjB;;EAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI1F,kBAAJ,gDAA8D8B,IAA9D,2BAAN,CANW;EASb;;EACA,SAAKuD,WAAL,CAAiBvD,IAAjB,EAAuB,UAAAzL,IAAI,EAAI;EAC7B,MAAA,MAAI,CAAC6V,QAAL,CAAc7V,IAAd;EACD,KAFD,EAVa;;EAeb,SAAKF,MAAL,WAAmB2L,IAAnB,EAfa;;;EAkBb,SAAKrH,IAAL,CAAU,aAAV,EAAyB;EACvB6C,MAAAA,GAAG,EAAEwE,IADkB;EAEvBpK,MAAAA,UAAU,EAAEgO,QAAQ,CAAChO;EAFE,KAAzB;EAID;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEwU,WAAA,kBAAS7V,IAAT,EAAe;EACb,QAAIyK,QAAJ;;EAEA,QAAIvL,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;EACxB,UAAMM,MAAM,GAAG,KAAKT,SAAS,CAAC,CAAD,CAA7B;EAAA,UACMD,MAAM,GAAG,KAAKC,SAAS,CAAC,CAAD,CAD7B;EAGAuL,MAAAA,QAAQ,GAAGhL,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeV,MAAf,EAAuB,KAAKW,IAA5B,CAA1B;EAEA,UAAI,CAAC6K,QAAL,EACE,MAAM,IAAId,kBAAJ,gDAA8DhK,MAA9D,qBAA6EV,MAA7E,2BAAN;EACH,KARD,MASK;EACHe,MAAAA,IAAI,GAAG,KAAKA,IAAZ;EAEAyK,MAAAA,QAAQ,GAAG,KAAKuB,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAX;EAEA,UAAI,CAACyK,QAAL,EACE,MAAM,IAAId,kBAAJ,gDAA8D3J,IAA9D,2BAAN;EACH,KAnBY;;;EAsBb,SAAKgM,MAAL,WAAmBvB,QAAQ,CAACxD,GAA5B,EAtBa;;;EAyBb,oBAIIwD,QAJJ;EAAA,QACU5K,UADV,aACEF,MADF;EAAA,QAEU+K,UAFV,aAEEzL,MAFF;EAAA,QAGEoC,UAHF,aAGEA,UAHF;EAMA,QAAMnB,UAAU,GAAGuK,QAAQ,CAACvK,UAA5B;;EAEA,QAAIL,UAAU,KAAK6K,UAAnB,EAA+B;EAC7B,UAAIxK,UAAJ,EAAgB;EACdL,QAAAA,UAAU,CAACqK,mBAAX;EACA,aAAK4J,wBAAL;EACD,OAHD,MAIK;EACHjU,QAAAA,UAAU,CAACoK,iBAAX;EACA,aAAK8J,sBAAL;EACD;EACF,KATD,MAUK;EACH,UAAI7T,UAAJ,EAAgB;EACdL,QAAAA,UAAU,CAACmK,gBAAX;EACAU,QAAAA,UAAU,CAACV,gBAAX;EACD,OAHD,MAIK;EACHnK,QAAAA,UAAU,CAACkK,SAAX;EACAW,QAAAA,UAAU,CAACZ,QAAX;EACD;EACF,KApDY;;;EAuDboB,IAAAA,2BAA2B,CAAC,IAAD,EAAOhL,UAAP,EAAmBuK,QAAnB,CAA3B;EAEA,QAAIvK,UAAJ,EACE,KAAK8T,eAAL,GADF,KAGE,KAAKC,aAAL,GA5DW;;EA+Db,SAAK7P,IAAL,CAAU,aAAV,EAAyB;EACvB6C,MAAAA,GAAG,EAAEjH,IADkB;EAEvBqB,MAAAA,UAAU,EAAVA,UAFuB;EAGvB1B,MAAAA,MAAM,EAAEE,UAAU,CAACoH,GAHI;EAIvBhI,MAAAA,MAAM,EAAEyL,UAAU,CAACzD,GAJI;EAKvB/G,MAAAA,UAAU,EAAVA;EALuB,KAAzB;EAQA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE4V,QAAA,iBAAQ;EAEN;EACA,SAAK9J,MAAL,CAAY8J,KAAZ,GAHM;;;EAMN,SAAKhW,MAAL,CAAYgW,KAAZ,GANM;;;EASN,SAAK1R,IAAL,CAAU,SAAV;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE2R,aAAA,sBAAa;EAEX;EACA,SAAK/J,MAAL,CAAY8J,KAAZ,GAHW;;;EAMX,SAAKE,UAAL,GANW;;EASX,SAAK5R,IAAL,CAAU,cAAV;EACD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;EACA;;;WACE6R,eAAA,sBAAarV,IAAb,EAAmB;EACjB,WAAO,KAAKsV,WAAL,CAAiBtV,IAAjB,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACEuV,gBAAA,yBAAgB;EACd,WAAO,KAAKD,WAAZ;EACD;EAED;EACF;EACA;EACA;EACA;EACA;;;WACEE,eAAA,sBAAaxV,IAAb,EAAmB;EACjB,WAAO,KAAKsV,WAAL,CAAiB/J,cAAjB,CAAgCvL,IAAhC,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACEyV,eAAA,sBAAazV,IAAb,EAAmBR,KAAnB,EAA0B;EACxB,SAAK8V,WAAL,CAAiBtV,IAAjB,IAAyBR,KAAzB,CADwB;;EAIxB,SAAKgE,IAAL,CAAU,mBAAV,EAA+B;EAC7BxE,MAAAA,IAAI,EAAE,KADuB;EAE7ByB,MAAAA,UAAU,EAAE,KAAK6U,WAFY;EAG7BtV,MAAAA,IAAI,EAAJA;EAH6B,KAA/B;EAMA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACE0V,kBAAA,yBAAgB1V,IAAhB,EAAsB0L,OAAtB,EAA+B;EAC7B,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAI7C,0BAAJ,CAA+B,sDAA/B,CAAN;EAEF,QAAMrJ,KAAK,GAAG,KAAK8V,WAAL,CAAiBtV,IAAjB,CAAd;EAEA,SAAKsV,WAAL,CAAiBtV,IAAjB,IAAyB0L,OAAO,CAAClM,KAAD,CAAhC,CAN6B;;EAS7B,SAAKgE,IAAL,CAAU,mBAAV,EAA+B;EAC7BxE,MAAAA,IAAI,EAAE,KADuB;EAE7ByB,MAAAA,UAAU,EAAE,KAAK6U,WAFY;EAG7BtV,MAAAA,IAAI,EAAJA;EAH6B,KAA/B;EAMA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;;;WACE2V,kBAAA,yBAAgB3V,IAAhB,EAAsB;EACpB,WAAO,KAAKsV,WAAL,CAAiBtV,IAAjB,CAAP,CADoB;;EAIpB,SAAKwD,IAAL,CAAU,mBAAV,EAA+B;EAC7BxE,MAAAA,IAAI,EAAE,QADuB;EAE7ByB,MAAAA,UAAU,EAAE,KAAK6U,WAFY;EAG7BtV,MAAAA,IAAI,EAAJA;EAH6B,KAA/B;EAMA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE4V,oBAAA,2BAAkBnV,UAAlB,EAA8B;EAC5B,QAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,CAA+B,sEAA/B,CAAN;EAEF,SAAKyM,WAAL,GAAmB7U,UAAnB,CAJ4B;;EAO5B,SAAK+C,IAAL,CAAU,mBAAV,EAA+B;EAC7BxE,MAAAA,IAAI,EAAE,SADuB;EAE7ByB,MAAAA,UAAU,EAAE,KAAK6U;EAFY,KAA/B;EAKA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEO,kBAAA,yBAAgBpV,UAAhB,EAA4B;EAC1B,QAAI,CAACd,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,CAA+B,oEAA/B,CAAN;EAEFlK,IAAAA,MAAM,CAAC,KAAK2W,WAAN,EAAmB7U,UAAnB,CAAN,CAJ0B;;EAO1B,SAAK+C,IAAL,CAAU,mBAAV,EAA+B;EAC7BxE,MAAAA,IAAI,EAAE,OADuB;EAE7ByB,MAAAA,UAAU,EAAE,KAAK6U,WAFY;EAG7B1M,MAAAA,IAAI,EAAEnI;EAHuB,KAA/B;EAMA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEqV,mBAAA,0BAAiBjL,IAAjB,EAAuB7K,IAAvB,EAA6B;EAC3B6K,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,wDAAsE8B,IAAtE,2BAAN;EAEF,WAAOjC,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE+V,oBAAA,2BAAkBlL,IAAlB,EAAwB;EACtBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,yDAAuE8B,IAAvE,2BAAN;EAEF,WAAOjC,IAAI,CAACnI,UAAZ;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEuV,mBAAA,0BAAiBnL,IAAjB,EAAuB7K,IAAvB,EAA6B;EAC3B6K,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,wDAAsE8B,IAAtE,2BAAN;EAEF,WAAOjC,IAAI,CAACnI,UAAL,CAAgB8K,cAAhB,CAA+BvL,IAA/B,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEiW,mBAAA,0BAAiBpL,IAAjB,EAAuB7K,IAAvB,EAA6BR,KAA7B,EAAoC;EAClCqL,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,wDAAsE8B,IAAtE,2BAAN;EAEF,QAAIvM,SAAS,CAACG,MAAV,GAAmB,CAAvB,EACE,MAAM,IAAIoK,0BAAJ,CAA+B,sLAA/B,CAAN;EAEFD,IAAAA,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,IAAwBR,KAAxB,CAXkC;;EAclC,SAAKgE,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEwE,IAD4B;EAEjC7L,MAAAA,IAAI,EAAE,KAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEkW,sBAAA,6BAAoBrL,IAApB,EAA0B7K,IAA1B,EAAgC0L,OAAhC,EAAyC;EACvCb,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,2DAAyE8B,IAAzE,2BAAN;EAEF,QAAIvM,SAAS,CAACG,MAAV,GAAmB,CAAvB,EACE,MAAM,IAAIoK,0BAAJ,CAA+B,2LAA/B,CAAN;EAEF,QAAI,OAAO6C,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAI7C,0BAAJ,CAA+B,sDAA/B,CAAN;EAEF,QAAMpI,UAAU,GAAGmI,IAAI,CAACnI,UAAxB;EACA,QAAMjB,KAAK,GAAGkM,OAAO,CAACjL,UAAU,CAACT,IAAD,CAAX,CAArB;EAEAS,IAAAA,UAAU,CAACT,IAAD,CAAV,GAAmBR,KAAnB,CAjBuC;;EAoBvC,SAAKgE,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEwE,IAD4B;EAEjC7L,MAAAA,IAAI,EAAE,KAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEmW,sBAAA,6BAAoBtL,IAApB,EAA0B7K,IAA1B,EAAgC;EAC9B6K,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,2DAAyE8B,IAAzE,2BAAN;EAEF,WAAOjC,IAAI,CAACnI,UAAL,CAAgBT,IAAhB,CAAP,CAR8B;;EAW9B,SAAKwD,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEwE,IAD4B;EAEjC7L,MAAAA,IAAI,EAAE,QAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCT,MAAAA,IAAI,EAAJA;EAJiC,KAAnC;EAOA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEoW,wBAAA,+BAAsBvL,IAAtB,EAA4BpK,UAA5B,EAAwC;EACtCoK,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,6DAA2E8B,IAA3E,2BAAN;EAEF,QAAI,CAAClL,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,CAA+B,0EAA/B,CAAN;EAEFD,IAAAA,IAAI,CAACnI,UAAL,GAAkBA,UAAlB,CAXsC;;EActC,SAAK+C,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEwE,IAD4B;EAEjC7L,MAAAA,IAAI,EAAE,SAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI;EAHgB,KAAnC;EAMA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE4V,sBAAA,6BAAoBxL,IAApB,EAA0BpK,UAA1B,EAAsC;EACpCoK,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,2DAAyE8B,IAAzE,2BAAN;EAEF,QAAI,CAAClL,aAAa,CAACc,UAAD,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,CAA+B,wEAA/B,CAAN;EAEFlK,IAAAA,MAAM,CAACiK,IAAI,CAACnI,UAAN,EAAkBA,UAAlB,CAAN,CAXoC;;EAcpC,SAAK+C,IAAL,CAAU,uBAAV,EAAmC;EACjC6C,MAAAA,GAAG,EAAEwE,IAD4B;EAEjC7L,MAAAA,IAAI,EAAE,OAF2B;EAGjCyB,MAAAA,UAAU,EAAEmI,IAAI,CAACnI,UAHgB;EAIjCmI,MAAAA,IAAI,EAAEnI;EAJ2B,KAAnC;EAOA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;;;WACE6V,2BAAA,kCAAyB5K,OAAzB,EAAkClL,KAAlC,EAAyC;EACvC,QAAI,OAAOkL,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAI7C,0BAAJ,CAA+B,gEAA/B,CAAN;EAEF,QAAIrI,KAAK,IAAI,CAACD,aAAa,CAACC,KAAD,CAA3B,EACE,MAAM,IAAIqI,0BAAJ,CAA+B,wHAA/B,CAAN;;EAEF,QAAMT,QAAQ,GAAG,KAAKlJ,MAAL,CAAYiO,MAAZ,EAAjB;;EAEA,QAAIlF,IAAJ,EAAUwG,QAAV;;EAEA,WAAQxG,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnDyG,MAAAA,QAAQ,GAAGxG,IAAI,CAACzI,KAAhB;EACAiP,MAAAA,QAAQ,CAAChO,UAAT,GAAsBiL,OAAO,CAAC+C,QAAQ,CAACpI,GAAV,EAAeoI,QAAQ,CAAChO,UAAxB,CAA7B;EACD;;EAED,SAAK+C,IAAL,CAAU,2BAAV,EAAuC;EACrChD,MAAAA,KAAK,EAAEA,KAAK,GAAGA,KAAH,GAAW;EADc,KAAvC;EAGD;EAED;EACF;EACA;EACA;EACA;EACA;;;WACE+V,2BAAA,kCAAyB7K,OAAzB,EAAkClL,KAAlC,EAAyC;EACvC,QAAI,OAAOkL,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAI7C,0BAAJ,CAA+B,gEAA/B,CAAN;EAEF,QAAIrI,KAAK,IAAI,CAACD,aAAa,CAACC,KAAD,CAA3B,EACE,MAAM,IAAIqI,0BAAJ,CAA+B,wHAA/B,CAAN;;EAEF,QAAMT,QAAQ,GAAG,KAAKgD,MAAL,CAAY+B,MAAZ,EAAjB;;EAEA,QAAIlF,IAAJ,EAAU4B,QAAV;;EAEA,WAAQ5B,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnD6B,MAAAA,QAAQ,GAAG5B,IAAI,CAACzI,KAAhB;EACAqK,MAAAA,QAAQ,CAACpJ,UAAT,GAAsBiL,OAAO,CAAC7B,QAAQ,CAACxD,GAAV,EAAewD,QAAQ,CAACpJ,UAAxB,CAA7B;EACD;;EAED,SAAK+C,IAAL,CAAU,2BAAV,EAAuC;EACrChD,MAAAA,KAAK,EAAEA,KAAK,GAAGA,KAAH,GAAW;EADc,KAAvC;EAGD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;;;WACEmK,UAAA,iBAAQkC,QAAR,EAAkB;EAChB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIhE,0BAAJ,CAA+B,sCAA/B,CAAN;EAEF,QAAI,KAAKkB,KAAT,EACE0H,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc5E,QAAd,CAArB,CADF,KAGE0E,sBAAsB,CAAC,KAAD,EAAQ,IAAR,EAAc1E,QAAd,CAAtB;EACH;EAED;EACF;EACA;EACA;EACA;EACA;;;WACE2J,eAAA,sBAAa3J,QAAb,EAAuB;EACrB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIhE,0BAAJ,CAA+B,sCAA/B,CAAN;EAEF,QAAI,KAAKkB,KAAT,EACE,OAAO0H,qBAAqB,CAAC,IAAD,EAAO,IAAP,EAAa5E,QAAb,CAA5B;EAEF,WAAO0E,sBAAsB,CAAC,IAAD,EAAO,IAAP,EAAa1E,QAAb,CAA7B;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE4J,YAAA,qBAAY;EACV,QAAI,KAAK1M,KAAT,EACE,OAAO8H,4BAA4B,CAAC,IAAD,CAAnC;EAEF,WAAOF,6BAA6B,CAAC,IAAD,CAApC;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE+E,QAAA,iBAAQ;EACN,QAAI,OAAOhW,KAAK,CAACsN,IAAb,KAAsB,UAA1B,EACE,OAAOtN,KAAK,CAACsN,IAAN,CAAW,KAAK9O,MAAL,CAAYkH,IAAZ,EAAX,CAAP;EAEF,WAAOoC,IAAI,CAAC,KAAKtJ,MAAL,CAAYkH,IAAZ,EAAD,EAAqB,KAAKlH,MAAL,CAAYsL,IAAjC,CAAX;EACD;EAED;EACF;EACA;EACA;EACA;;;WACEmM,cAAA,qBAAY9J,QAAZ,EAAsB;EACpB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIhE,0BAAJ,CAA+B,0CAA/B,CAAN;;EAEF,SAAK3J,MAAL,CAAYyL,OAAZ,CAAoB,UAAC/B,IAAD,EAAOvC,GAAP,EAAe;EACjCwG,MAAAA,QAAQ,CAACxG,GAAD,EAAMuC,IAAI,CAACnI,UAAX,CAAR;EACD,KAFD;EAGD;EAED;EACF;EACA;EACA;EACA;EACA;;;WACEmW,mBAAA,0BAAiB/J,QAAjB,EAA2B;EACzB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIhE,0BAAJ,CAA+B,0CAA/B,CAAN;;EAEF,QAAMT,QAAQ,GAAG,KAAKlJ,MAAL,CAAYiO,MAAZ,EAAjB;;EAEA,QAAIlF,IAAJ,EAAUwG,QAAV,EAAoBxB,WAApB;;EAEA,WAAQhF,IAAI,GAAGG,QAAQ,CAACL,IAAT,EAAP,EAAwBE,IAAI,CAACD,IAAL,KAAc,IAA9C,EAAqD;EACnDyG,MAAAA,QAAQ,GAAGxG,IAAI,CAACzI,KAAhB;EAEAyN,MAAAA,WAAW,GAAGJ,QAAQ,CAAC4B,QAAQ,CAACpI,GAAV,EAAeoI,QAAQ,CAAChO,UAAxB,CAAtB;EAEA,UAAIwM,WAAJ,EACE,OAAO,IAAP;EACH;;EAED,WAAO,KAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE4J,cAAA,uBAAc;EACZ,QAAMzO,UAAQ,GAAG,KAAKlJ,MAAL,CAAYiO,MAAZ,EAAjB;;EAEA,WAAO,IAAIrF,QAAJ,CAAa,YAAM;EACxB,UAAMG,IAAI,GAAGG,UAAQ,CAACL,IAAT,EAAb;EAEA,UAAIE,IAAI,CAACD,IAAT,EACE,OAAOC,IAAP;EAEF,UAAMW,IAAI,GAAGX,IAAI,CAACzI,KAAlB;EAEA,aAAO;EAACA,QAAAA,KAAK,EAAE,CAACoJ,IAAI,CAACvC,GAAN,EAAWuC,IAAI,CAACnI,UAAhB,CAAR;EAAqCuH,QAAAA,IAAI,EAAE;EAA3C,OAAP;EACD,KATM,CAAP;EAUD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACE8O,aAAA,oBAAWjM,IAAX,EAAiB;EACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMjC,IAAI,GAAG,KAAK1J,MAAL,CAAYC,GAAZ,CAAgB0L,IAAhB,CAAb;;EAEA,QAAI,CAACjC,IAAL,EACE,MAAM,IAAIG,kBAAJ,kDAAgE8B,IAAhE,2BAAN;EAEF,WAAOiH,aAAa,CAACjH,IAAD,EAAOjC,IAAP,CAApB;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;EACA;;;WACEmO,aAAA,oBAAW3X,IAAX,EAAiB;EACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;EAEA,QAAMwJ,IAAI,GAAG,KAAKwC,MAAL,CAAYjM,GAAZ,CAAgBC,IAAhB,CAAb;;EAEA,QAAI,CAACwJ,IAAL,EACE,MAAM,IAAIG,kBAAJ,kDAAgE3J,IAAhE,2BAAN;EAEF,WAAO4S,aAAa,CAAC5S,IAAD,EAAOwJ,IAAP,CAApB;EACD;EAED;EACF;EACA;EACA;EACA;;;uBACE,mBAAS;EAEP,QAAM8N,KAAK,GAAG,IAAIhW,KAAJ,CAAU,KAAKxB,MAAL,CAAYsL,IAAtB,CAAd;EAEA,QAAIjM,CAAC,GAAG,CAAR;;EAEA,SAAKW,MAAL,CAAYyL,OAAZ,CAAoB,UAAC/B,IAAD,EAAOvC,GAAP,EAAe;EACjCqQ,MAAAA,KAAK,CAACnY,CAAC,EAAF,CAAL,GAAauT,aAAa,CAACzL,GAAD,EAAMuC,IAAN,CAA1B;EACD,KAFD;;EAIA,QAAMmC,KAAK,GAAG,IAAIrK,KAAJ,CAAU,KAAK0K,MAAL,CAAYZ,IAAtB,CAAd;EAEAjM,IAAAA,CAAC,GAAG,CAAJ;;EAEA,SAAK6M,MAAL,CAAYT,OAAZ,CAAoB,UAAC/B,IAAD,EAAOvC,GAAP,EAAe;EACjC0E,MAAAA,KAAK,CAACxM,CAAC,EAAF,CAAL,GAAayT,aAAa,CAAC3L,GAAD,EAAMuC,IAAN,CAA1B;EACD,KAFD;;EAIA,WAAO;EACLnI,MAAAA,UAAU,EAAE,KAAK8U,aAAL,EADP;EAELmB,MAAAA,KAAK,EAALA,KAFK;EAGL3L,MAAAA,KAAK,EAALA,KAHK;EAIL2I,MAAAA,OAAO,EAAE;EACP1U,QAAAA,IAAI,EAAE,KAAKA,IADJ;EAEP+K,QAAAA,KAAK,EAAE,KAAKA,KAFL;EAGP0I,QAAAA,cAAc,EAAE,KAAKA;EAHd;EAJJ,KAAP;EAUD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACEuE,aAAA,oBAAWpO,IAAX,EAAgC;EAAA,QAAfoH,KAAe,uEAAP,KAAO;EAE9B;EACA,QAAMpM,KAAK,GAAGqO,sBAAsB,CAACrJ,IAAD,CAApC;;EAEA,QAAIhF,KAAJ,EAAW;EAET,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,uHAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,QAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,oCAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,6FAA/B,CAAN;EACH,KAb6B;;;EAgB9B,QAAOxC,GAAP,GAA+BuC,IAA/B,CAAOvC,GAAP;EAAA,2BAA+BuC,IAA/B,CAAYnI,UAAZ;EAAA,QAAYA,UAAZ,iCAAyB,EAAzB;EAEA,QAAIuP,KAAJ,EACE,KAAK+E,SAAL,CAAe1O,GAAf,EAAoB5F,UAApB,EADF,KAGE,KAAKkS,OAAL,CAAatM,GAAb,EAAkB5F,UAAlB;EAEF,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACEwW,aAAA,oBAAWrO,IAAX,EAAgC;EAAA,QAAfoH,KAAe,uEAAP,KAAO;EAE9B;EACA,QAAMpM,KAAK,GAAGsO,sBAAsB,CAACtJ,IAAD,CAApC;;EAEA,QAAIhF,KAAJ,EAAW;EAET,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,qIAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,WAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,kCAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,WAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,mCAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,6FAA/B,CAAN;EACF,UAAIjF,KAAK,KAAK,oBAAd,EACE,MAAM,IAAIiF,0BAAJ,CAA+B,gFAA/B,CAAN;EACH,KAjB6B;;;EAoB9B,QACE9J,MADF,GAKI6J,IALJ,CACE7J,MADF;EAAA,QAEEV,MAFF,GAKIuK,IALJ,CAEEvK,MAFF;EAAA,4BAKIuK,IALJ,CAGEnI,UAHF;EAAA,QAGEA,UAHF,kCAGe,EAHf;EAAA,2BAKImI,IALJ,CAIEtJ,UAJF;EAAA,QAIEA,UAJF,iCAIe,KAJf;EAOA,QAAI4L,MAAJ;;EAEA,QAAI,SAAStC,IAAb,EAAmB;EACjBsC,MAAAA,MAAM,GAAG8E,KAAK,GACX1Q,UAAU,GAAG,KAAK4X,0BAAR,GAAqC,KAAKC,wBADzC,GAEX7X,UAAU,GAAG,KAAKG,wBAAR,GAAmC,KAAK2X,sBAFrD;EAIAlM,MAAAA,MAAM,CAAC7J,IAAP,CACE,IADF,EAEEuH,IAAI,CAACvC,GAFP,EAGEtH,MAHF,EAIEV,MAJF,EAKEoC,UALF;EAOD,KAZD,MAaK;EACHyK,MAAAA,MAAM,GAAG8E,KAAK,GACX1Q,UAAU,GAAG,KAAK+X,mBAAR,GAA8B,KAAKC,iBADlC,GAEXhY,UAAU,GAAG,KAAKiY,iBAAR,GAA4B,KAAKC,eAF9C;EAIAtM,MAAAA,MAAM,CAAC7J,IAAP,CACE,IADF,EAEEtC,MAFF,EAGEV,MAHF,EAIEoC,UAJF;EAMD;;EAED,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;uBACE,iBAAOmI,IAAP,EAA4B;EAAA,QAAfoH,KAAe,uEAAP,KAAO;;EAE1B;EACA,QAAIzQ,OAAO,CAACqJ,IAAD,CAAX,EAAmB;EAEjB,qBAAYA,IAAI,UAAJ,EAAZ,EAA2BoH,KAA3B;EACA,aAAO,IAAP;EACD,KAPyB;;;EAU1B,QAAI,CAACrQ,aAAa,CAACiJ,IAAD,CAAlB,EACE,MAAM,IAAIC,0BAAJ,CAA+B,mGAA/B,CAAN;;EAEF,QAAID,IAAI,CAACnI,UAAT,EAAqB;EACnB,UAAI,CAACd,aAAa,CAACiJ,IAAI,CAACnI,UAAN,CAAlB,EACE,MAAM,IAAIoI,0BAAJ,CAA+B,6DAA/B,CAAN;EAEF,UAAImH,KAAJ,EACE,KAAK6F,eAAL,CAAqBjN,IAAI,CAACnI,UAA1B,EADF,KAGE,KAAKmV,iBAAL,CAAuBhN,IAAI,CAACnI,UAA5B;EACH;;EAED,QAAIlC,CAAJ,EAAOC,CAAP,EAAUqH,IAAV;;EAEA,QAAI+C,IAAI,CAAC8N,KAAT,EAAgB;EACd7Q,MAAAA,IAAI,GAAG+C,IAAI,CAAC8N,KAAZ;EAEA,UAAI,CAAChW,KAAK,CAACC,OAAN,CAAckF,IAAd,CAAL,EACE,MAAM,IAAIgD,0BAAJ,CAA+B,kDAA/B,CAAN;;EAGF,WAAKtK,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGqH,IAAI,CAACpH,MAArB,EAA6BF,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC;EACE,aAAKyY,UAAL,CAAgBnR,IAAI,CAACtH,CAAD,CAApB,EAAyByR,KAAzB;EADF;EAED;;EAED,QAAIpH,IAAI,CAACmC,KAAT,EAAgB;EACdlF,MAAAA,IAAI,GAAG+C,IAAI,CAACmC,KAAZ;EAEA,UAAI,CAACrK,KAAK,CAACC,OAAN,CAAckF,IAAd,CAAL,EACE,MAAM,IAAIgD,0BAAJ,CAA+B,kDAA/B,CAAN;;EAEF,WAAKtK,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGqH,IAAI,CAACpH,MAArB,EAA6BF,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC;EACE,aAAK0Y,UAAL,CAAgBpR,IAAI,CAACtH,CAAD,CAApB,EAAyByR,KAAzB;EADF;EAED;;EAED,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;EACA;EACA;;;WACEyH,WAAA,kBAAS/D,OAAT,EAAkB;EAChB,WAAO,IAAIzH,KAAJ,CAAUtN,MAAM,CAAC,EAAD,EAAK,KAAKkV,QAAV,EAAoBH,OAApB,CAAhB,CAAP;EACD;EAED;EACF;EACA;EACA;EACA;EACA;EACA;;;WACEgE,YAAA,mBAAUhE,OAAV,EAAmB;EACjB,QAAM5U,KAAK,GAAG,KAAK2Y,QAAL,CAAc/D,OAAd,CAAd;;EAEA,SAAKxU,MAAL,CAAYyL,OAAZ,CAAoB,UAAC8D,QAAD,EAAWpI,GAAX,EAAmB;EACrC,UAAM5F,UAAU,GAAG9B,MAAM,CAAC,EAAD,EAAK8P,QAAQ,CAAChO,UAAd,CAAzB,CADqC;;EAIrCgO,MAAAA,QAAQ,GAAG,IAAI3P,KAAK,CAAC8T,aAAV,CAAwBvM,GAAxB,EAA6B5F,UAA7B,CAAX;;EACA3B,MAAAA,KAAK,CAACI,MAAN,CAAa4D,GAAb,CAAiBuD,GAAjB,EAAsBoI,QAAtB;EACD,KAND;;EAQA,WAAO3P,KAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACEgI,OAAA,gBAAO;EACL,QAAMhI,KAAK,GAAG,IAAImN,KAAJ,CAAU,KAAK4H,QAAf,CAAd;EACA/U,IAAAA,KAAK,UAAL,CAAa,IAAb;EAEA,WAAOA,KAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE0K,iBAAA,0BAAiB;EACf,QAAI,KAAKxK,IAAL,KAAc,OAAlB,EACE,OAAO,IAAP,CAFa;EAKf;EACA;EACA;EACA;;EACA,SAAKE,MAAL,CAAYyL,OAAZ,CAAoB,UAAA/B,IAAI;EAAA,aAAKA,IAAI,CAACY,cAAL,EAAL;EAAA,KAAxB,EATe;;;EAYf,SAAKqK,QAAL,CAAc7U,IAAd,GAAqB,OAArB;EACAqB,IAAAA,gBAAgB,CAAC,IAAD,EAAO,MAAP,EAAe,KAAKwT,QAAL,CAAc7U,IAA7B,CAAhB;EACAe,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwBkJ,aAAxB,CAAf;EAEA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACE0O,iBAAA,0BAAiB;EACf,QAAI,KAAK5N,KAAT,EACE,OAAO,IAAP,CAFa;;EAKf,SAAK8J,QAAL,CAAc9J,KAAd,GAAsB,IAAtB;EACA1J,IAAAA,gBAAgB,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CAAhB,CANe;;EASfuK,IAAAA,4BAA4B,CAAC,IAAD,CAA5B;EAEA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;;;WACEwK,aAAA,sBAAa;EACX1K,IAAAA,mBAAmB,CAAC,IAAD,CAAnB;EACA,WAAO,IAAP;EACD;EAED;EACF;EACA;EACA;;EAEE;EACF;EACA;EACA;EACA;;;WACEkN,SAAA,kBAAS;EACP,WAAO,gBAAP;EACD;EAED;EACF;EACA;;;WACEC,WAAA,oBAAW;EACT,WAAO,gBAAP;EACD;EAED;EACF;EACA;EACA;EACA;;;WACEC,UAAA,mBAAU;EAAA;;EACR,QAAMpB,KAAK,GAAG,EAAd;;EACA,SAAKxX,MAAL,CAAYyL,OAAZ,CAAoB,UAAC/B,IAAD,EAAOvC,GAAP,EAAe;EACjCqQ,MAAAA,KAAK,CAACrQ,GAAD,CAAL,GAAauC,IAAI,CAACnI,UAAlB;EACD,KAFD;;EAIA,QAAMsK,KAAK,GAAG,EAAd;EAAA,QACMgN,UAAU,GAAG,EADnB;;EAGA,SAAK3M,MAAL,CAAYT,OAAZ,CAAoB,UAAC/B,IAAD,EAAOvC,GAAP,EAAe;EACjC,UAAMmG,SAAS,GAAG5D,IAAI,CAACtJ,UAAL,GAAkB,IAAlB,GAAyB,IAA3C;EAEA,UAAI0Y,KAAK,GAAG,EAAZ;EAEA,UAAMC,IAAI,cAAOrP,IAAI,CAAC7J,MAAL,CAAYsH,GAAnB,cAA0BmG,SAA1B,cAAuC5D,IAAI,CAACvK,MAAL,CAAYgI,GAAnD,MAAV;;EAEA,UAAI,CAACuC,IAAI,CAACe,YAAV,EAAwB;EACtBqO,QAAAA,KAAK,eAAQ3R,GAAR,QAAL;EACD,OAFD,MAGK,IAAI,MAAI,CAAC0D,KAAT,EAAgB;EACnB,YAAI,OAAOgO,UAAU,CAACE,IAAD,CAAjB,KAA4B,WAAhC,EAA6C;EAC3CF,UAAAA,UAAU,CAACE,IAAD,CAAV,GAAmB,CAAnB;EACD,SAFD,MAGK;EACHF,UAAAA,UAAU,CAACE,IAAD,CAAV;EACD;;EAEDD,QAAAA,KAAK,cAAOD,UAAU,CAACE,IAAD,CAAjB,OAAL;EACD;;EAEDD,MAAAA,KAAK,IAAIC,IAAT;EAEAlN,MAAAA,KAAK,CAACiN,KAAD,CAAL,GAAepP,IAAI,CAACnI,UAApB;EACD,KAxBD;;EA0BA,QAAMyX,KAAK,GAAG,EAAd;;EAEA,SAAK,IAAMxZ,CAAX,IAAgB,IAAhB,EAAsB;EACpB,UAAI,KAAK6M,cAAL,CAAoB7M,CAApB,KACA,CAAC0T,aAAa,CAAC9C,GAAd,CAAkB5Q,CAAlB,CADD,IAEA,OAAO,KAAKA,CAAL,CAAP,KAAmB,UAFvB,EAGEwZ,KAAK,CAACxZ,CAAD,CAAL,GAAW,KAAKA,CAAL,CAAX;EACH;;EAEDwZ,IAAAA,KAAK,CAACzX,UAAN,GAAmB,KAAK6U,WAAxB;EACA4C,IAAAA,KAAK,CAACxB,KAAN,GAAcA,KAAd;EACAwB,IAAAA,KAAK,CAACnN,KAAN,GAAcA,KAAd;EAEAhL,IAAAA,eAAe,CAACmY,KAAD,EAAQ,aAAR,EAAuB,KAAKtY,WAA5B,CAAf;EAEA,WAAOsY,KAAP;EACD;;;IAl4DgChW;EAw4DnC,IAAI,OAAOiG,MAAP,KAAkB,WAAtB,EACE8D,KAAK,CAAC7K,SAAN,CAAgB+G,MAAM,OAAN,CAAW,4BAAX,CAAhB,IAA4D8D,KAAK,CAAC7K,SAAN,CAAgB0W,OAA5E;EAEF;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EACAzF,gBAAgB,CAAC1H,OAAjB,CAAyB,UAAAO,MAAM,EAAI;EACjC,GAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2BP,OAA3B,CAAmC,UAAA2H,IAAI,EAAI;EACzC,QAAMtS,IAAI,GAAGkL,MAAM,CAAClL,IAAP,CAAYsS,IAAZ,CAAb;EAAA,QACM5D,EAAE,GAAG4D,IAAI,KAAK,KAAT,GAAiBQ,OAAjB,GAA2BQ,SADtC;;EAGA,QAAIpI,MAAM,CAACqH,WAAX,EAAwB;EACtBtG,MAAAA,KAAK,CAAC7K,SAAN,CAAgBpB,IAAhB,IAAwB,UAASjB,MAAT,EAAiBV,MAAjB,EAAyBoC,UAAzB,EAAqC;EAC3D,eAAOiO,EAAE,CACP,IADO,EAEP1O,IAFO,EAGP,IAHO,EAIP,CAACkL,MAAM,CAAClM,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKP,IALO,EAMPD,MANO,EAOPV,MAPO,EAQPoC,UARO,EASP6R,IAAI,KAAK,QATF,CAAT;EAWD,OAZD;EAaD,KAdD,MAeK;EACHrG,MAAAA,KAAK,CAAC7K,SAAN,CAAgBpB,IAAhB,IAAwB,UAASZ,IAAT,EAAeL,MAAf,EAAuBV,MAAvB,EAA+BoC,UAA/B,EAA2C;EACjE,eAAOiO,EAAE,CACP,IADO,EAEP1O,IAFO,EAGP,KAHO,EAIP,CAACkL,MAAM,CAAClM,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKPI,IALO,EAMPL,MANO,EAOPV,MAPO,EAQPoC,UARO,EASP6R,IAAI,KAAK,QATF,CAAT;EAWD,OAZD;EAaD;EACF,GAlCD;EAmCD,CApCD;EAsCA;EACA;EACA;;EACA,IAAI,OAAOnK,MAAP,KAAkB,WAAtB,EACE8D,KAAK,CAAC7K,SAAN,CAAgB+G,MAAM,CAACC,QAAvB,IAAmC6D,KAAK,CAAC7K,SAAN,CAAgBqV,SAAnD;EAEF;EACA;EACA;;EACAzK,uBAAuB,CAACC,KAAD,CAAvB;EAEA;EACA;EACA;;EACA6D,0BAA0B,CAAC7D,KAAD,CAA1B;EAEA;EACA;EACA;;EACAqF,8BAA8B,CAACrF,KAAD,CAA9B;;ECt+EA;EACA;EACA;;MACMkM;;;EACJ,yBAAYzE,OAAZ,EAAqB;EACnB,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC;EAACK,MAAAA,IAAI,EAAE;EAAP,KAAD,EAAqB0U,OAArB,CAA3B;EAEA,QAAI,WAAW0E,YAAX,IAA2BA,YAAY,CAACrO,KAAb,KAAuB,KAAtD,EACE,MAAM,IAAIlB,0BAAJ,CAA+B,8FAA/B,CAAN;EAEF,QAAIuP,YAAY,CAACpZ,IAAb,KAAsB,UAA1B,EACA,MAAM,IAAI6J,0BAAJ,CAA+B,uCAAuCuP,YAAY,CAACpZ,IAApD,GAA2D,0BAA1F,CAAN;EAPmB,WASnB,kBAAMoZ,YAAN,CATmB;EAUpB;;;IAXyBnM;;MAatBoM;;;EACJ,2BAAY3E,OAAZ,EAAqB;EACnB,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC;EAACK,MAAAA,IAAI,EAAE;EAAP,KAAD,EAAuB0U,OAAvB,CAA3B;EAEA,QAAI,WAAW0E,YAAX,IAA2BA,YAAY,CAACrO,KAAb,KAAuB,KAAtD,EACE,MAAM,IAAIlB,0BAAJ,CAA+B,gGAA/B,CAAN;EAEF,QAAIuP,YAAY,CAACpZ,IAAb,KAAsB,YAA1B,EACE,MAAM,IAAI6J,0BAAJ,CAA+B,yCAAyCuP,YAAY,CAACpZ,IAAtD,GAA6D,0BAA5F,CAAN;EAPiB,WASnB,mBAAMoZ,YAAN,CATmB;EAUpB;;;IAX2BnM;;MAaxBqM;;;EACJ,sBAAY5E,OAAZ,EAAqB;EACnB,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC;EAACoL,MAAAA,KAAK,EAAE;EAAR,KAAD,EAAgB2J,OAAhB,CAA3B;EAEA,QAAI,WAAW0E,YAAX,IAA2BA,YAAY,CAACrO,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIlB,0BAAJ,CAA+B,4FAA/B,CAAN;EAJiB,WAMnB,mBAAMuP,YAAN,CANmB;EAOpB;;;IARsBnM;;MAUnBsM;;;EACJ,8BAAY7E,OAAZ,EAAqB;EACnB,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC;EAACK,MAAAA,IAAI,EAAE,UAAP;EAAmB+K,MAAAA,KAAK,EAAE;EAA1B,KAAD,EAAkC2J,OAAlC,CAA3B;EAEA,QAAI,WAAW0E,YAAX,IAA2BA,YAAY,CAACrO,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIlB,0BAAJ,CAA+B,oGAA/B,CAAN;EAEF,QAAIuP,YAAY,CAACpZ,IAAb,KAAsB,UAA1B,EACE,MAAM,IAAI6J,0BAAJ,CAA+B,4CAA4CuP,YAAY,CAACpZ,IAAzD,GAAgE,0BAA/F,CAAN;EAPiB,WASnB,mBAAMoZ,YAAN,CATmB;EAUpB;;;IAX8BnM;;MAa3BuM;;;EACJ,gCAAY9E,OAAZ,EAAqB;EACnB,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC;EAACK,MAAAA,IAAI,EAAE,YAAP;EAAqB+K,MAAAA,KAAK,EAAE;EAA5B,KAAD,EAAoC2J,OAApC,CAA3B;EAEA,QAAI,WAAW0E,YAAX,IAA2BA,YAAY,CAACrO,KAAb,KAAuB,IAAtD,EACE,MAAM,IAAIlB,0BAAJ,CAA+B,sGAA/B,CAAN;EAEF,QAAIuP,YAAY,CAACpZ,IAAb,KAAsB,YAA1B,EACE,MAAM,IAAI6J,0BAAJ,CAA+B,8CAA8CuP,YAAY,CAACpZ,IAA3D,GAAkE,0BAAjG,CAAN;EAPiB,WASnB,mBAAMoZ,YAAN,CATmB;EAUpB;;;IAXgCnM;EAcnC;EACA;EACA;;;EACA,SAASwM,sBAAT,CAAgCxN,KAAhC,EAAuC;EAErC;EACF;EACA;EACA;EACA;EACA;EACA;EACEA,EAAAA,KAAK,CAAC+C,IAAN,GAAa,UAASpF,IAAT,EAAe8K,OAAf,EAAwB;EAEnC;EACA,QAAM0E,YAAY,GAAGzZ,MAAM,CAAC,EAAD,EAAKiK,IAAI,CAAC8K,OAAV,EAAmBA,OAAnB,CAA3B;EAEA,QAAMgF,QAAQ,GAAG,IAAIzN,KAAJ,CAAUmN,YAAV,CAAjB;EACAM,IAAAA,QAAQ,UAAR,CAAgB9P,IAAhB;EAEA,WAAO8P,QAAP;EACD,GATD;EAUD;;EAEDD,sBAAsB,CAACxM,KAAD,CAAtB;EACAwM,sBAAsB,CAACN,aAAD,CAAtB;EACAM,sBAAsB,CAACJ,eAAD,CAAtB;EACAI,sBAAsB,CAACH,UAAD,CAAtB;EACAG,sBAAsB,CAACF,kBAAD,CAAtB;EACAE,sBAAsB,CAACD,oBAAD,CAAtB;EAEAvM,KAAK,CAACA,KAAN,GAAcA,KAAd;EACAA,KAAK,CAACkM,aAAN,GAAsBA,aAAtB;EACAlM,KAAK,CAACoM,eAAN,GAAwBA,eAAxB;EACApM,KAAK,CAACqM,UAAN,GAAmBA,UAAnB;EACArM,KAAK,CAACsM,kBAAN,GAA2BA,kBAA3B;EACAtM,KAAK,CAACuM,oBAAN,GAA6BA,oBAA7B;EAEAvM,KAAK,CAACpD,0BAAN,GAAmCA,0BAAnC;EACAoD,KAAK,CAAClD,kBAAN,GAA2BA,kBAA3B;EACAkD,KAAK,CAACjD,eAAN,GAAwBA,eAAxB;;EC1HA;EACA;EACA;EACA;EACA;EACA;;;;;;;;"}